<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sanrico Mercantile - Staff Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/modal.css">
    <link rel="stylesheet" href="css/tooltip.css">
    <link rel="stylesheet" href="css/staff-dashboard.css">
    <script src="js/auth.js"></script>
    <script src="js/toast.js"></script>
    <style>
        /* Collection badges for debugging/clarity */
        .collection-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
            margin-left: 5px;
            text-transform: uppercase;
        }
        
        .collection-badge.pending {
            background: rgba(255, 193, 7, 0.2);
            color: #856404;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }
        
        .collection-badge.accepted {
            background: rgba(40, 167, 69, 0.2);
            color: #155724;
            border: 1px solid rgba(40, 167, 69, 0.3);
        }
        
        .collection-badge.delivered {
            background: rgba(111, 66, 193, 0.2);
            color: #4c2c92;
            border: 1px solid rgba(111, 66, 193, 0.3);
        }
        
        /* Loading animations */
        .loading-dots {
            display: inline-block;
            animation: loadingBob 1.5s ease-in-out infinite;
        }
        
        @keyframes loadingBob {
            0%, 20%, 80%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-3px);
            }
        }
        
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            flex-direction: column;
            gap: 1rem;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #e63946;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #666;
            font-size: 0.9rem;
            text-align: center;
        }
        
        /* Filters with refresh button layout */
        .filters-with-refresh {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
            margin-left: auto;
        }
        
        .refresh-btn-thin {
            min-width: 45px !important;
            width: 45px !important;
            height: 42px !important;
            padding: 0 !important;
            font-size: 1.2rem !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        /* Search and date dropdown styles */
        .search-and-date-section {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
            flex: 1;
            margin-right: 1rem;
        }
        
        .search-and-date-section .form-control {
            min-width: 250px;
            flex: 1;
        }
        
        .search-input-container {
            position: relative;
            flex: 1;
            max-width: 400px;
            min-width: 300px;
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--dark-gray);
            font-size: 1rem;
            pointer-events: none;
            z-index: 1;
        }
        
        .search-input-with-icon {
            padding-left: 40px !important;
        }
        
        .section-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            justify-content: space-between;
            width: 100%;
        }
        
        .date-dropdown-container {
            position: relative;
            flex-shrink: 0;
        }
        
        .date-dropdown-btn {
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .date-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            background: var(--card-bg);
            border: 1px solid var(--input-border);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            min-width: 320px;
            z-index: 1000;
            display: none;
        }
        
        .date-dropdown.show {
            display: block;
        }
        
        .date-dropdown-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--input-border);
        }
        
        .date-dropdown-header h4 {
            margin: 0;
            color: var(--text);
            font-size: 1rem;
            font-weight: 600;
        }
        
        .date-dropdown-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--dark-gray);
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .date-dropdown-close:hover {
            background: var(--input-bg);
            color: var(--text);
        }
        
        .date-dropdown .date-range-filter {
            margin-bottom: 1.5rem;
        }
        
        .date-dropdown-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        
        .date-dropdown-actions .action-btn {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        /* Active state for date dropdown button */
        .date-dropdown-btn.active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .search-and-date-section {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-and-date-section .form-control {
                min-width: auto;
            }
            
            .date-dropdown {
                left: 50%;
                transform: translateX(-50%);
                min-width: 280px;
            }
        }
        
        /* Status change buttons styling */
        .modal-actions .action-btn[data-status] {
            margin: 0 0.25rem;
        }
        
        .modal-actions .action-btn[data-status]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Order Denial Dialog Styling */
        #orderDenialDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            border: none;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            min-width: 450px;
            max-width: 90vw;
            padding: 0;
            background: transparent;
            z-index: 1002;
        }
        
        #orderDenialDialog::backdrop {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        .denial-dialog-content {
            background: var(--card-bg, #fff);
            padding: 2rem;
            border-radius: 12px;
        }
        
        .denial-dialog-content h3 {
            margin: 0 0 1rem 0;
            color: var(--text, #333);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .denial-dialog-content p {
            margin: 0 0 1.5rem 0;
            color: var(--text-muted, #666);
            line-height: 1.5;
        }
        
        .denial-dialog-content .form-group {
            margin-bottom: 1.5rem;
        }
        
        .denial-dialog-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text, #333);
        }
        
        .denial-dialog-content textarea {
            width: 100%;
            min-height: 80px;
            padding: 0.75rem;
            border: 1px solid var(--input-border, #ddd);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .denial-dialog-content textarea:focus {
            outline: none;
            border-color: var(--primary, #e63946);
            box-shadow: 0 0 0 3px rgba(230, 57, 70, 0.1);
        }
        
        .denial-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        .denial-dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .denial-dialog-actions .action-btn.secondary {
            background: var(--light-gray, #f8f9fa);
            color: var(--text, #333);
        }
        
        .denial-dialog-actions .action-btn.secondary:hover {
            background: var(--border-color, #e0e0e0);
        }
        
        .denial-dialog-actions .action-btn.cancel {
            background: var(--danger, #dc3545);
            color: white;
        }
        
        .denial-dialog-actions .action-btn.cancel:hover {
            background: var(--danger-dark, #c82333);
        }
        
        @media (max-width: 480px) {
            #orderDenialDialog {
                min-width: 320px;
            }
            
            .denial-dialog-content {
                padding: 1.5rem;
            }
            
            .denial-dialog-actions {
                flex-direction: column;
                gap: 0.75rem;
            }
        }
        
        /* Order Approval Dialog Styling */
        #orderApprovalDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            border: none;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            min-width: 450px;
            max-width: 90vw;
            padding: 0;
            background: transparent;
            z-index: 1002;
        }
        
        #orderApprovalDialog::backdrop {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        .approval-dialog-content {
            background: var(--card-bg, #fff);
            padding: 2rem;
            border-radius: 12px;
        }
        
        .approval-dialog-content h3 {
            margin: 0 0 1rem 0;
            color: var(--success, #28a745);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .approval-dialog-content p {
            margin: 0 0 1.5rem 0;
            color: var(--text-muted, #666);
            line-height: 1.5;
        }
        
        .approval-note {
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid rgba(40, 167, 69, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .approval-note p {
            margin: 0;
            color: var(--success, #28a745);
            font-size: 0.9rem;
        }
        
        .approval-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        .approval-dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .approval-dialog-actions .action-btn.secondary {
            background: var(--light-gray, #f8f9fa);
            color: var(--text, #333);
        }
        
        .approval-dialog-actions .action-btn.secondary:hover {
            background: var(--border-color, #e0e0e0);
        }
        
        .approval-dialog-actions .action-btn.primary {
            background: var(--success, #28a745);
            color: white;
        }
        
        .approval-dialog-actions .action-btn.primary:hover {
            background: var(--success-dark, #218838);
        }
        
        /* Order Delivery Dialog Styling */
        #orderDeliveryDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            border: none;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            min-width: 450px;
            max-width: 90vw;
            padding: 0;
            background: transparent;
            z-index: 1002;
        }
        
        #orderDeliveryDialog::backdrop {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        .delivery-dialog-content {
            background: var(--card-bg, #fff);
            padding: 2rem;
            border-radius: 12px;
        }
        
        .delivery-dialog-content h3 {
            margin: 0 0 1rem 0;
            color: var(--primary, #007bff);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .delivery-dialog-content p {
            margin: 0 0 1.5rem 0;
            color: var(--text-muted, #666);
            line-height: 1.5;
        }
        
        .delivery-note {
            background: rgba(0, 123, 255, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .delivery-note p {
            margin: 0;
            color: var(--primary, #007bff);
            font-size: 0.9rem;
        }
        
        .delivery-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        .delivery-dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .delivery-dialog-actions .action-btn.secondary {
            background: var(--light-gray, #f8f9fa);
            color: var(--text, #333);
        }
        
        .delivery-dialog-actions .action-btn.secondary:hover {
            background: var(--border-color, #e0e0e0);
        }
        
        .delivery-dialog-actions .action-btn.primary {
            background: var(--primary, #007bff);
            color: white;
        }
        
        .delivery-dialog-actions .action-btn.primary:hover {
            background: var(--primary-dark, #0056b3);
        }
        
        /* Order Return Dialog Styling */
        #orderReturnDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            border: none;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            min-width: 500px;
            max-width: 90vw;
            padding: 0;
            background: transparent;
            z-index: 1002;
        }
        
        #orderReturnDialog::backdrop {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }
        
        .return-dialog-content {
            background: var(--card-bg, #fff);
            padding: 2rem;
            border-radius: 12px;
        }
        
        .return-dialog-content h3 {
            margin: 0 0 1rem 0;
            color: var(--warning, #f39c12);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .return-dialog-content p {
            margin: 0 0 1.5rem 0;
            color: var(--text-muted, #666);
            line-height: 1.5;
        }
        
        .return-dialog-content .form-group {
            margin-bottom: 1.5rem;
        }
        
        .return-dialog-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text, #333);
        }
        
        .return-dialog-content textarea {
            width: 100%;
            min-height: 80px;
            padding: 0.75rem;
            border: 1px solid var(--input-border, #ddd);
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
        }
        
        .return-dialog-content textarea:focus {
            outline: none;
            border-color: var(--warning, #f39c12);
            box-shadow: 0 0 0 3px rgba(243, 156, 18, 0.1);
        }
        
        .return-drop-zone {
            border: 2px dashed var(--input-border, #ddd);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            background: var(--input-bg, #f8f9fa);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .return-drop-zone:hover {
            border-color: var(--warning, #f39c12);
            background: rgba(243, 156, 18, 0.05);
        }
        
        .return-drop-zone.dragover {
            border-color: var(--warning, #f39c12);
            background: rgba(243, 156, 18, 0.1);
            transform: scale(1.02);
        }
        
        .return-note {
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .return-note p {
            margin: 0;
            color: var(--warning, #f39c12);
            font-size: 0.9rem;
        }
        
        .return-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }
        
        .return-dialog-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .return-dialog-actions .action-btn.secondary {
            background: var(--light-gray, #f8f9fa);
            color: var(--text, #333);
        }
        
        .return-dialog-actions .action-btn.secondary:hover {
            background: var(--border-color, #e0e0e0);
        }
        
        .return-dialog-actions .action-btn.primary {
            background: var(--warning, #f39c12);
            color: white;
        }
        
        .return-dialog-actions .action-btn.primary:hover {
            background: var(--warning-dark, #e67e22);
        }
        
        @media (max-width: 480px) {
            #orderReturnDialog {
                min-width: 320px;
            }
            
            .return-dialog-content {
                padding: 1.5rem;
            }
            
            .return-dialog-actions {
                flex-direction: column;
                gap: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="staff-header">
        <div class="container header-container">
            <div class="logo-container">
                <img src="images/sanrico_logo_1.png" alt="Sanrico Mercantile Logo" class="logo-img">
                <div class="logo">
                    Sanrico <span>Mercantile</span> - Staff Dashboard
                </div>
            </div>
            <div class="header-controls">
                <div class="notification-container">
                    <button class="notification-btn" id="notificationBtn">
                        <span class="notification-icon">üîî</span>
                        <span class="notification-text">Notifications</span>
                        <span class="notification-badge" id="notificationBadge">0</span>
                    </button>
                    <div class="notification-dropdown" id="notificationDropdown">
                        <div class="notification-header">
                            <h3>Notifications</h3>
                            <button class="clear-all-btn" id="clearAllBtn">Clear All</button>
                        </div>
                        <div class="notification-list" id="notificationList">
                            <!-- Notifications will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="staff-info">
                    <span id="staffName">Staff Member</span>
                    <button class="logout-btn" id="logoutBtn">Logout</button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Dashboard Layout -->
    <div class="dashboard-layout">
        <!-- Left Sidebar Navigation -->
        <aside class="sidebar">
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <h3 class="nav-section-title">Management</h3>
                    <button class="nav-item active" data-section="dashboard">
                        <span class="nav-icon">üìä</span>
                        <span class="nav-text">Dashboard</span>
                    </button>
                    <button class="nav-item" data-section="products">
                        <span class="nav-icon">üì¶</span>
                        <span class="nav-text">Product Management</span>
                    </button>
                    <button class="nav-item" data-section="orders" id="ordersNavButton" title="No actions required">
                        <span class="nav-icon">üìã</span>
                        <span class="nav-text">Order Management</span>
                        <span class="nav-badge" id="ordersBadge">0</span>
                    </button>
                    <button class="nav-item" data-section="returns" id="returnsNavButton" title="No return requests">
                        <span class="nav-icon">‚Ü©Ô∏è</span>
                        <span class="nav-text">Returns & Exchanges</span>
                        <span class="nav-badge" id="returnsBadge">0</span>
                    </button>
                </div>
                <div class="nav-section">
                    <h3 class="nav-section-title">Point of Sale</h3>
                    <button class="nav-item" data-section="cashier">
                        <span class="nav-icon">üí∞</span>
                        <span class="nav-text">Cashier POS</span>
                    </button>
                </div>
            </nav>
        </aside>

        <!-- Main Content Area -->
        <main class="main-content">
            <!-- Dashboard Overview Section -->
            <section class="content-section active" id="dashboard-section">
                <div class="section-header">
                    <h1>Dashboard Overview</h1>
                    <div class="date-range-selector">
                        <input type="date" id="dashboardStartDate" class="form-control">
                        <span>to</span>
                        <input type="date" id="dashboardEndDate" class="form-control">
                        <button class="action-btn primary" id="refreshDashboard">Refresh</button>
                    </div>
                </div>

                <!-- Dashboard Stats -->
                <div class="dashboard-stats">
                    <div class="stat-card clickable" id="totalProductsCard" data-section="products">
                        <div class="stat-icon">üì¶</div>
                        <div class="stat-info">
                            <div class="stat-number" id="totalProducts">0</div>
                            <div class="stat-label">Total Products</div>
                        </div>
                    </div>
                    <div class="stat-card clickable" id="pendingOrdersCard" data-section="orders">
                        <div class="stat-icon">üìã</div>
                        <div class="stat-info">
                            <div class="stat-number" id="pendingOrders">0</div>
                            <div class="stat-label">Pending Orders</div>
                        </div>
                    </div>
                    <div class="stat-card clickable" id="deliveredOrdersCard" data-section="orders">
                        <div class="stat-icon">‚úÖ</div>
                        <div class="stat-info">
                            <div class="stat-number" id="completedOrders">0</div>
                            <div class="stat-label">Delivered Orders</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">üöö</div>
                        <div class="stat-info">
                            <div class="stat-number" id="deliveredProducts">0</div>
                            <div class="stat-label">Delivered Products</div>
                        </div>
                    </div>
                    <div class="stat-card" id="walkInOrdersCard">
                        <div class="stat-icon">üö∂</div>
                        <div class="stat-info">
                            <div class="stat-number" id="walkInOrders">0</div>
                            <div class="stat-label">Walk-in Orders</div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-icon">üí∞</div>
                        <div class="stat-info">
                            <div class="stat-number" id="totalRevenue">‚Ç±0.00</div>
                            <div class="stat-label">Total Revenue</div>
                        </div>
                    </div>
                </div>

                <!-- Dashboard Content Grid -->
                <div class="dashboard-content-grid">
                    <!-- Recent Activity -->
                    <div class="recent-activity">
                        <h2>Recent Activity</h2>
                        <div class="activity-list" id="activityList">
                            <!-- Recent activities will be populated here -->
                        </div>
                    </div>

                    <!-- Low Stock Alerts -->
                        <div class="low-stock-alerts">
                        <div class="low-stock-header">
                            <h2>‚ö†Ô∏è Low Stock Alerts</h2>
                            <button class="action-btn small secondary low-stock-view-all" id="navigateToLowStockProducts">
                                üì¶ View All
                            </button>
                        </div>
                        <div class="low-stock-list" id="lowStockList">
                            <!-- Low stock products will be populated here -->
                        </div>
                    </div>
                </div>
            </section>

            <!-- Product Management Section -->
            <section class="content-section" id="products-section">
                <div class="section-header">
                    <h1>Product Management</h1>
                    <div class="section-controls">
                        <select id="categoryFilter" class="form-control">
                            <option value="all">All Categories</option>
                            <option value="tools-accessories">Tools & Accessories</option>
                            <option value="building-materials-aggregates">Building Materials & Aggregates</option>
                            <option value="electrical-supplies">Electrical Supplies</option>
                            <option value="plumbing-fixtures">Plumbing & Fixtures</option>
                            <option value="fasteners-consumables">Fasteners & Consumables</option>
                            <option value="paints">Paints</option>
                            <option value="other">Other</option>
                        </select>
                        <input type="text" id="productSearch" class="form-control" placeholder="Search products...">
                    </div>
                </div>
                <div class="products-table-container">
                    <table class="products-table" id="productsTable">
                        <thead>
                            <tr>
                                <th>Image</th>
                                <th>Product Name</th>
                                <th>Category</th>
                                <th>Price</th>
                                <th>Stock</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="productsTableBody">
                            <!-- Products will be populated here -->
                        </tbody>
                    </table>
                </div>
                <div class="pagination" id="productsPagination"></div>
            </section>

            <!-- Order Management Section -->
            <section class="content-section" id="orders-section">
                <div class="section-header">
                    <h1>Order Management</h1>
                    <div class="section-controls">
                        <div class="search-and-date-section">
                            <div class="search-input-container">
                                <span class="search-icon">üîç</span>
                                <input type="text" id="orderSearch" class="form-control search-input-with-icon" placeholder="Insert user's name/ID or their order ID">
                            </div>
                            <div class="date-dropdown-container">
                                <button class="action-btn secondary date-dropdown-btn" id="dateDropdownBtn">üìÖ Specific Dates</button>
                                <div class="date-dropdown" id="dateDropdown">
                                    <div class="date-dropdown-header">
                                        <h4>Filter by Date Range</h4>
                                        <button class="date-dropdown-close" id="dateDropdownClose">√ó</button>
                                    </div>
                                    <div class="date-range-filter">
                                        <label>From:</label>
                                        <input type="date" id="orderStartDate" class="form-control">
                                        <label>To:</label>
                                        <input type="date" id="orderEndDate" class="form-control">
                                    </div>
                                    <div class="date-dropdown-actions">
                                        <button class="action-btn secondary" id="clearDatesBtn">Clear</button>
                                        <button class="action-btn primary" id="applyDatesBtn">Apply</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="filters-with-refresh">
                            <select id="orderStatusFilter" class="form-control">
                                <option value="all">All Orders</option>
                                <option value="pending">Pending</option>
                                <option value="approved">Approved</option>
                                <option value="delivered">Delivered</option>
                                <option value="returned">Returned</option>
                                <option value="cancelled">Cancelled</option>
                                <option value="completed">Walk-in/Completed</option>
                            </select>
                            <select id="paymentMethodFilter" class="form-control">
                                <option value="all">All Payment Methods</option>
                                <option value="cash">Cash</option>
                                <option value="gcash">GCash</option>
                                <option value="bank">Bank Transfer</option>
                                <option value="cheque">Cheque</option>
                            </select>
                            <button class="action-btn primary refresh-btn-thin" id="refreshOrdersBtn">üîÑ</button>
                        </div>
                    </div>
                </div>
                <div class="orders-table-container">
                    <table class="orders-table" id="ordersTable">
                        <thead>
                            <tr>
                                <th>Order ID</th>
                                <th>Customer</th>
                                <th>Items</th>
                                <th>Total</th>
                                <th>Payment Method</th>
                                <th>Shipping</th>
                                <th>Date</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="ordersTableBody">
                            <!-- Orders will be populated here -->
                        </tbody>
                    </table>
                </div>
                <div class="pagination" id="ordersPagination"></div>
            </section>

            <!-- Cashier POS Section -->
            <section class="content-section" id="cashier-section">
                <div class="section-header">
                    <h1>Cashier Point of Sale</h1>
                    <div class="pos-controls" style="display: flex; gap: 1rem; align-items: center;">
                        <button class="action-btn secondary" id="clearCartBtn">Clear Cart</button>
                        <div class="new-transaction-container">
                            <button class="action-btn primary" id="newTransactionBtn">New Transaction ‚ñº</button>
                            <div class="new-transaction-dropdown" id="newTransactionDropdown">
                                <div class="dropdown-header">
                                    <h4 id="newTransactionOrderId">Order #TXN-001</h4>
                                    <button class="dropdown-close" id="newTransactionClose">√ó</button>
                                </div>
                                <div class="dropdown-body">
                                    <div class="form-group">
                                        <label>Customer Name:</label>
                                        <input type="text" id="newTransactionCustomerName" class="form-control" placeholder="Enter customer name">
                                    </div>
                                </div>
                                <div class="dropdown-actions">
                                    <button class="action-btn secondary" id="cancelNewTransaction">Cancel</button>
                                    <button class="action-btn primary" id="startNewTransaction">Start Transaction</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="pos-layout">
                    <!-- Product Selection Area -->
                    <div class="pos-products">
                        <div class="pos-search">
                            <div class="pos-search-container">
                                <input type="text" id="posProductSearch" class="form-control" placeholder="Search product...">
                                <button class="action-btn primary" id="scanProductBtn">
                                    <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                                        <circle cx="11" cy="11" r="8"/>
                                        <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="pos-categories">
                            <button class="category-btn active" data-category="all">All</button>
                            <button class="category-btn" data-category="tools-accessories">Tools & Accessories</button>
                            <button class="category-btn" data-category="building-materials-aggregates">Building Materials</button>
                            <button class="category-btn" data-category="plumbing-fixtures">Plumbing</button>
                            <button class="category-btn" data-category="electrical-supplies">Electrical</button>
                            <button class="category-btn" data-category="fasteners-consumables">Fasteners</button>
                            <button class="category-btn" data-category="paints">Paints</button>
                        </div>
                        <div class="pos-products-grid" id="posProductsGrid">
                            <!-- POS Products will be loaded here -->
                        </div>
                    </div>

                    <!-- Cart and Checkout Area -->
                    <div class="pos-cart">
                        <div class="cart-header">
                            <h3>Current Order</h3>
                            <span class="cart-count" id="cartCount">0 items</span>
                        </div>
                        <div class="cart-items" id="cartItems">
                            <div class="empty-cart">
                                <p>No items in cart</p>
                            </div>
                        </div>
                        <div class="cart-summary">
                            <div class="summary-row">
                                <span>Subtotal:</span>
                                <span id="subtotal">‚Ç±0.00</span>
                            </div>
                            <div class="summary-row total">
                                <span>Total:</span>
                                <span id="total">‚Ç±0.00</span>
                            </div>
                        </div>
                        <div class="checkout-section">
                            <div class="customer-info-display" id="customerInfoDisplay">
                                <div class="customer-display-text">No customer set</div>
                            </div>
                            <button class="action-btn primary checkout-btn" id="checkoutBtn" disabled>
                                Complete Transaction
                            </button>
                            <div class="cancel-transaction-link-container">
                                <a href="#" class="cancel-transaction-link" onclick="event.preventDefault(); staffDashboard.cancelTransaction();">
                                    Cancel Transaction
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Returns & Exchanges Section -->
            <section class="content-section" id="returns-section">
                <div class="section-header">
                    <h1>Returns & Exchanges</h1>
                    <div class="section-controls">
                        <select id="returnStatusFilter" class="form-control">
                            <option value="all">All Returns</option>
                            <option value="pending">Pending Review</option>
                            <option value="approved">Approved</option>
                            <option value="rejected">Rejected</option>
                            <option value="completed">Completed</option>
                        </select>
                        <button class="action-btn primary" id="refreshReturnsBtn">üîÑ Refresh</button>
                    </div>
                </div>

                <div class="returns-table-container">
                    <table class="returns-table" id="returnsTable">
                        <thead>
                            <tr>
                                <th>Order ID</th>
                                <th>Customer</th>
                                <th>Return Type</th>
                                <th>Reason</th>
                                <th>Items</th>
                                <th>Request Date</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="returnsTableBody">
                            <!-- Return requests will be populated here -->
                        </tbody>
                    </table>
                </div>
                <div class="pagination" id="returnsPagination"></div>
            </section>
        </main>
    </div>

    <!-- Product Edit Modal -->
    <div class="modal" id="productModal">
        <div class="modal-content">
            <button class="modal-close" id="productModalClose">√ó</button>
            <h2 class="modal-title">Edit Product</h2>
            
            <div class="product-edit-form">
                <div class="form-group">
                    <label>Product Name:</label>
                    <input type="text" id="productName" readonly class="form-control readonly-field">
                </div>
                
                <div class="form-group">
                    <label>Product Image:</label>
                    <div class="image-upload-section">
                        <div class="drop-zone" id="dropZone">
                            <div class="drop-zone-content">
                                <div class="upload-icon">üìÅ</div>
                                <p>Drag and drop an image here or click to browse</p>
                                <input type="file" id="fileInput" accept="image/*" hidden>
                            </div>
                            <div class="image-preview hidden" id="imagePreview">
                                <img id="previewImg" src="images/sanrico_logo_1.png" alt="Preview">
                            </div>
                        </div>
                        <button type="button" class="action-btn cancel hidden" id="removeImageBtn">Remove Image</button>
                    </div>
                </div>

                <div class="form-group">
                    <label>Stock Quantity:</label>
                    <input type="number" id="productStock" class="form-control" min="0" readonly style="background-color: #f8f9fa; color: #6c757d; cursor: not-allowed;">
                </div>
            </div>

            <div class="modal-actions">
                <button class="action-btn cancel" id="cancelEdit">Cancel</button>
                <button class="action-btn primary" id="saveProduct">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Order Details Modal -->
    <div class="modal" id="orderModal">
        <div class="modal-content order-modal-content">
            <button class="modal-close" id="orderModalClose">√ó</button>
            
            <!-- Header -->
            <div class="modal-header">
                <h2 class="modal-title">Order Details</h2>
            </div>
            
            <div class="order-details-form">
                <!-- Order Info Card -->
                <div class="order-card-section">
                    <div class="order-header-card">
                        <div class="order-id-section">
                            <h3 id="staffModalOrderId">#12345</h3>
                            <button class="copy-btn" onclick="copyStaffOrderId()">Copy</button>
                        </div>
                        <div class="order-date-section">
                            <span id="staffModalOrderDate">Jun 25, 2025 5:53 PM</span>
                        </div>
                    </div>
                </div>

                <!-- Customer Information Card -->
                <div class="order-card-section">
                    <h3 class="section-title">Customer Information</h3>
                    <div class="info-grid" id="staffCustomerInfo">
                        <!-- Customer info will be populated here -->
                    </div>
                </div>
                
                <!-- Order Summary Card -->
                <div class="order-card-section">
                    <h3 class="section-title">Order Summary</h3>
                    <div class="items-list-modern" id="staffModalOrderItems">
                        <!-- Items will be populated here -->
                    </div>
                    
                    <div class="order-totals">
                        <div class="total-row">
                            <span>Subtotal</span>
                            <span id="staffModalSubtotal">‚Ç±0.00</span>
                        </div>
                        <div class="total-row">
                            <span>Delivery Fee</span>
                            <span id="staffModalDeliveryFee">‚Ç±0.00</span>
                        </div>
                        <div class="total-row final-total">
                            <span>Total</span>
                            <span id="staffModalTotal">‚Ç±0.00</span>
                        </div>
                    </div>
                </div>
                
                <!-- Staff Information Card -->
                <div class="order-card-section">
                    <h3 class="section-title">Staff Information</h3>
                    <div class="info-grid" id="staffOrderTechnicalInfo">
                        <!-- Technical info will be populated here -->
                    </div>
                </div>
                
                <!-- Payment Information Card -->
                <div class="order-card-section">
                    <h3 class="section-title">Payment Information</h3>
                    <div class="payment-info" id="staffPaymentInfo">
                        <!-- Payment info will be populated here -->
                    </div>
                </div>
            </div>

            <div class="modal-actions">
                <button class="action-btn cancel" id="closeOrderModal">Close</button>
                <button class="action-btn secondary" id="changeToPending" data-status="pending">Change to Pending</button>
                <button class="action-btn cancel" id="changeToDenied" data-status="denied">Change to Denied</button>
                <button class="action-btn primary" id="changeToApproved" data-status="approved">Change to Approved</button>
                <button class="action-btn primary" id="changeToDelivered" data-status="delivered">Change to Delivered</button>
                <button class="action-btn secondary" id="changeToReturned" data-status="returned">Change to Returned</button>
            </div>
        </div>
    </div>

    <!-- Payment Modal -->
    <div class="modal" id="paymentModal">
        <div class="modal-content">
            <button class="modal-close" id="paymentModalClose">√ó</button>
            <h2 class="modal-title">Payment Processing</h2>
            
            <div class="payment-summary">
                <div class="payment-total">
                    Total Amount: <span id="paymentTotal">‚Ç±0.00</span>
                </div>
            </div>

            <div class="payment-methods">
                <h3>Payment Method</h3>
                <div class="payment-options">
                    <label class="payment-option">
                        <input type="radio" name="paymentMethod" value="cash" checked>
                        <span>Cash</span>
                    </label>
                    <label class="payment-option">
                        <input type="radio" name="paymentMethod" value="gcash">
                        <span>GCash</span>
                    </label>
                    <label class="payment-option">
                        <input type="radio" name="paymentMethod" value="bank">
                        <span>Bank Transfer</span>
                    </label>
                </div>
            </div>

            <div class="cash-payment" id="cashPayment">
                <div class="form-group">
                    <label for="amountReceived">Amount Received:</label>
                    <input type="number" id="amountReceived" step="0.01" min="0" class="form-control" placeholder="0.00">
                </div>
                <div class="change-display">
                    <span>Change: </span>
                    <span id="changeAmount">‚Ç±0.00</span>
                </div>
            </div>

            <div class="modal-actions">
                <button class="action-btn cancel" id="cancelPayment">Cancel</button>
                <button class="action-btn primary" id="confirmPayment">Complete Payment</button>
            </div>
        </div>
    </div>

    <!-- Walk-in Order Modal -->
    <div class="modal" id="walkInModal">
        <div class="modal-content">
            <button class="modal-close" id="walkInModalClose">√ó</button>
            <h2 class="modal-title">Add Walk-in Order</h2>
            
            <div class="walkin-form">
                <div class="form-group">
                    <label>Customer Name:</label>
                    <input type="text" id="walkInCustomerName" class="form-control" placeholder="Enter customer name">
                </div>
                
                <div class="form-group">
                    <label>Phone Number (Optional):</label>
                    <input type="tel" id="walkInCustomerPhone" class="form-control" placeholder="Enter phone number">
                </div>
                
                <div class="form-group">
                    <label>Order Type:</label>
                    <select id="walkInOrderType" class="form-control">
                        <option value="pickup">Pickup</option>
                        <option value="delivery">Delivery</option>
                    </select>
                </div>
                
                <div class="form-group delivery-address hidden" id="deliveryAddressGroup">
                    <label>Delivery Address:</label>
                    <textarea id="walkInDeliveryAddress" class="form-control" rows="3" placeholder="Enter delivery address"></textarea>
                </div>
                
                <div class="form-group">
                    <label>Notes:</label>
                    <textarea id="walkInNotes" class="form-control" rows="3" placeholder="Additional notes..."></textarea>
                </div>
            </div>

            <div class="modal-actions">
                <button class="action-btn cancel" id="cancelWalkIn">Cancel</button>
                <button class="action-btn primary" id="saveWalkIn">Create Order</button>
            </div>
        </div>
    </div>

    <!-- Order Denial Dialog -->
    <dialog id="orderDenialDialog">
        <div class="denial-dialog-content">
            <h3>Deny Order</h3>
            <p>Are you sure you want to deny this order? This action cannot be undone.</p>
            <div class="form-group">
                <label for="denialReason">Reason for denial (optional):</label>
                <textarea id="denialReason" class="form-control" rows="3" placeholder="Enter reason for denial..."></textarea>
            </div>
            <form method="dialog" class="denial-dialog-actions">
                <button value="cancel" class="action-btn secondary">Cancel</button>
                <button value="confirm" class="action-btn cancel">Deny Order</button>
            </form>
        </div>
    </dialog>

    <!-- Order Approval Dialog -->
    <dialog id="orderApprovalDialog">
        <div class="approval-dialog-content">
            <h3>Approve Order</h3>
            <p>Are you sure you want to approve this order? The customer will be notified and the order will be moved to the approved orders list.</p>
            <div class="approval-note">
                <p><strong>Note:</strong> Once approved, the order will be ready for processing and delivery preparation.</p>
            </div>
            <form method="dialog" class="approval-dialog-actions">
                <button value="cancel" class="action-btn secondary">Cancel</button>
                <button value="confirm" class="action-btn primary">Approve Order</button>
            </form>
        </div>
    </dialog>

    <!-- Order Delivery Dialog -->
    <dialog id="orderDeliveryDialog">
        <div class="delivery-dialog-content">
            <h3>Mark as Delivered</h3>
            <p>Are you sure you want to mark this order as delivered? This confirms that the customer has received their order.</p>
            <div class="delivery-note">
                <p><strong>Note:</strong> Once marked as delivered, the order will be moved to the completed orders list and cannot be undone.</p>
            </div>
            <form method="dialog" class="delivery-dialog-actions">
                <button value="cancel" class="action-btn secondary">Cancel</button>
                <button value="confirm" class="action-btn primary">Mark as Delivered</button>
            </form>
        </div>
    </dialog>

    <!-- Order Return Dialog -->
    <dialog id="orderReturnDialog">
        <div class="return-dialog-content">
            <h3>Process Order Return</h3>
            <p>Are you sure you want to process this order as returned? Please upload an image of the returned item(s) for documentation.</p>
            <div class="form-group">
                <label for="returnReason">Reason for return (optional):</label>
                <textarea id="returnReason" class="form-control" rows="3" placeholder="Enter reason for return..."></textarea>
            </div>
            <div class="form-group">
                <label>Return Documentation Image:</label>
                <div class="image-upload-section">
                    <div class="return-drop-zone" id="returnDropZone">
                        <div class="drop-zone-content">
                            <div class="upload-icon">üìÅ</div>
                            <p>Drag and drop an image here or click to browse</p>
                            <input type="file" id="returnFileInput" accept="image/*" hidden>
                        </div>
                        <div class="image-preview hidden" id="returnImagePreview">
                            <img id="returnPreviewImg" src="images/sanrico_logo_1.png" alt="Return Documentation Preview">
                        </div>
                    </div>
                    <button type="button" class="action-btn cancel hidden" id="removeReturnImageBtn">Remove Image</button>
                </div>
            </div>
            <div class="return-note">
                <p><strong>Note:</strong> Once processed as returned, the order will be moved to the returned orders list and the return documentation will be saved.</p>
            </div>
            <form method="dialog" class="return-dialog-actions">
                <button value="cancel" class="action-btn secondary">Cancel</button>
                <button value="confirm" class="action-btn primary">Process Return</button>
            </form>
        </div>
    </dialog>

    <!-- Toast Container -->
    <div class="toast" id="toast"></div>

    <!-- Dashboard Loading Overlay -->
    <div class="dashboard-loading" id="dashboardLoading">
        <div class="dashboard-spinner">
            <div class="spinner"></div>
            <div class="loading-text">
                Loading Staff Dashboard<span class="loading-dots">...</span>
            </div>
        </div>
    </div>

    <script>
        // Check if user is logged in as staff
        function checkStaffAuth() {
            const currentUser = Auth.getCurrentUser();
            
            if (!currentUser) {
                console.warn('No current user found, redirecting to homepage...');
                window.location.href = 'index.html';
                return false;
            }
            
            if (!currentUser.isStaff) {
                console.warn('User is not staff (isStaff:', currentUser.isStaff, '), redirecting to homepage...');
                window.location.href = 'index.html';
                return false;
            }
            document.getElementById('staffName').textContent = currentUser.fullName || currentUser.staffId;
            return true;
        }

        // Initialize staff system with retry mechanism to ensure localStorage is ready
        function initializeStaffDashboard() {
            // Show loading screen immediately
            const dashboardLoading = document.getElementById('dashboardLoading');
            if (dashboardLoading) {
                dashboardLoading.classList.add('show');
            }
            
            let attempts = 0;
            const maxAttempts = 10;
            const checkInterval = 100;
            
            function attemptInitialization() {
                attempts++;
                console.log(`Staff dashboard initialization attempt ${attempts}/${maxAttempts}`);
                
                const currentUser = Auth.getCurrentUser();
                const staffFlag = localStorage.getItem('staffAuth');
                console.log('Current user during attempt:', currentUser);
                console.log('Staff auth flag:', staffFlag);
                console.log('Raw localStorage currentUser:', localStorage.getItem('currentUser'));
                console.log('All localStorage keys:', Object.keys(localStorage));
                
                // If we have staff flag but no current user, something cleared it
                if (staffFlag === 'true' && !currentUser) {
                    console.error('üö® STAFF AUTHENTICATION WAS CLEARED! Something interfered with the auth.');
                }
                
                if (currentUser && currentUser.isStaff) {
                    console.log('Staff authentication successful, initializing dashboard...');
                    document.getElementById('staffName').textContent = currentUser.fullName || currentUser.staffId;
                    
                    // Update loading text
                    const loadingText = dashboardLoading?.querySelector('.loading-text');
                    if (loadingText) {
                        loadingText.innerHTML = 'Setting up dashboard<span class="loading-dots">...</span>';
                    }
                    
                    // Initialize dashboard with a slight delay for smooth transition
                    setTimeout(() => {
                        const staffDashboard = new EnhancedStaffDashboard();
                        
                        // Hide loading screen after dashboard is initialized
                        setTimeout(() => {
                            if (dashboardLoading) {
                                dashboardLoading.classList.remove('show');
                            }
                        }, 800);
                    }, 300);
                    return;
                }
                
                if (attempts >= maxAttempts) {
                    console.error('Failed to authenticate staff after maximum attempts, redirecting...');
                    // Hide loading before redirect
                    if (dashboardLoading) {
                        dashboardLoading.classList.remove('show');
                    }
                    window.location.href = 'index.html';
                    return;
                }
                
                // Try again after a short delay
                setTimeout(attemptInitialization, checkInterval);
            }
            
            // Start the retry mechanism
            attemptInitialization();
        }

        // Generic logout handler for dashboard
        function handleLogout() {
                const currentUser = Auth.getCurrentUser();
                const staffId = currentUser ? currentUser.staffId : '';
                const result = Auth.logout();
                if (result.success) {
                    showToast(`${staffId} successfully logged out`);
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1000);
                } else {
                    showToast(result.message);
                }
            }

        // Helper function to format prices with commas
        function formatPrice(amount) {
            return parseFloat(amount).toLocaleString('en-PH', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }

        // Enhanced Staff Dashboard Class
        class EnhancedStaffDashboard {
            constructor() {
                this.products = [];
                this.orders = [];
                this.walkInOrders = []; // Will be loaded from database
                this.notifications = JSON.parse(localStorage.getItem('staffNotifications') || '[]');
                this.comprehensiveStats = null; // Will be loaded from database
                this.currentSection = 'dashboard';
                this.currentPage = 1;
                this.itemsPerPage = 10;
                this.currentEditingProduct = null;
                this.currentEditingOrder = null;
                this.cart = [];
                this.currentSearchQuery = '';
                this.currentCategory = null;
                this.posSearchTimeout = null;
                this.posSearchDropdown = null;
                this.currentTransaction = null; // Current POS transaction info
                
                this.initializeEventListeners();
                this.loadData();
                this.startOrderPolling();
                this.updateNotifications();
                this.setDefaultDates();
                this.initializePOSSearchDropdown();
            }

            setDefaultDates() {
                const today = new Date();
                const oneMonthAgo = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());
                
                // Set default dates only for dashboard, not for order filtering
                document.getElementById('dashboardStartDate').value = oneMonthAgo.toISOString().split('T')[0];
                document.getElementById('dashboardEndDate').value = today.toISOString().split('T')[0];
                
                // Leave order date filters empty to show all orders by default
                document.getElementById('orderStartDate').value = '';
                document.getElementById('orderEndDate').value = '';
            }

            // Initialize POS search dropdown functionality
            initializePOSSearchDropdown() {
                const posSearchContainer = document.querySelector('.pos-search-container');
                if (!posSearchContainer) return;

                // Create dropdown if it doesn't exist
                if (!this.posSearchDropdown) {
                    this.posSearchDropdown = document.createElement('div');
                    this.posSearchDropdown.className = 'pos-search-dropdown';
                    posSearchContainer.appendChild(this.posSearchDropdown);
                }

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    const posSearch = document.querySelector('.pos-search');
                    if (posSearch && !posSearch.contains(e.target)) {
                        this.hidePOSSearchDropdown();
                    }
                });
            }

            // Handle POS search input with real-time dropdown
            handlePOSSearchInput(e) {
                const query = e.target.value.trim();
                
                // Clear previous timeout
                if (this.posSearchTimeout) {
                    clearTimeout(this.posSearchTimeout);
                }

                // Set new timeout for better performance
                this.posSearchTimeout = setTimeout(() => {
                    this.updatePOSSearchResults(query);
                }, 300);
            }

            // Handle POS search form submission
            handlePOSSearch() {
                const query = document.getElementById('posProductSearch').value.trim().toLowerCase();
                
                // If there's a query, hide dropdown and show filtered grid
                if (query) {
                    this.hidePOSSearchDropdown();
                    this.currentSearchQuery = query;
                    this.filterPOSProducts();
                } else {
                    // If no query, show all products in current category
                    this.currentSearchQuery = '';
                    this.renderPOSProducts(this.currentCategory || 'all');
                }
            }

            // Find closest matches for POS search (adapted from headerSearch.js)
            findPOSMatches(query, products, limit = 5) {
                if (!query || !products.length) return [];
                
                // Filter only products with stock
                const availableProducts = products.filter(p => p.stock > 0);
                
                // First try to find exact matches
                const exactMatches = availableProducts.filter(product => 
                    product.name.toLowerCase() === query.toLowerCase()
                );

                if (exactMatches.length > 0) {
                    return exactMatches.slice(0, limit);
                }

                // If no exact matches, find partial matches
                const partialMatches = availableProducts
                    .filter(product => 
                        product.name.toLowerCase().includes(query.toLowerCase())
                    )
                    .slice(0, limit);

                return partialMatches;
            }

            // Update POS search results dropdown
            updatePOSSearchResults(query) {
                if (!this.posSearchDropdown || !this.products.length) return;

                if (!query) {
                    this.hidePOSSearchDropdown();
                    return;
                }

                const matches = this.findPOSMatches(query, this.products);

                if (matches.length > 0) {
                    this.posSearchDropdown.innerHTML = matches.map(product => `
                        <div class="pos-search-result-item" onclick="staffDashboard.addToCartFromSearch('${product.id}')">
                            <img src="${product.image.startsWith('data:image') ? product.image : 'images/' + product.image}" 
                                 alt="${product.name}" 
                                 onerror="this.src='images/sanrico_logo_1.png'">
                            <div class="pos-search-result-info">
                                <div class="pos-search-result-name">${product.name}</div>
                                <div class="pos-search-result-price">${formatPrice(product.price) || '‚Ç±0.00'}</div>
                                <div class="pos-search-result-stock">Stock: ${product.stock}</div>
                            </div>
                        </div>
                    `).join('');

                    this.showPOSSearchDropdown();
                } else {
                    this.posSearchDropdown.innerHTML = '<div class="pos-search-no-results">No products found</div>';
                    this.showPOSSearchDropdown();
                }
            }

            // Show POS search dropdown
            showPOSSearchDropdown() {
                if (this.posSearchDropdown) {
                    this.posSearchDropdown.classList.add('show');
                }
            }

            // Hide POS search dropdown
            hidePOSSearchDropdown() {
                if (this.posSearchDropdown) {
                    this.posSearchDropdown.classList.remove('show');
                }
            }

            // Add to cart from search dropdown
            addToCartFromSearch(productId) {
                this.addToCart(productId);
                this.hidePOSSearchDropdown();
                // Clear search input after adding
                document.getElementById('posProductSearch').value = '';
                this.currentSearchQuery = '';
            }

            // Loading animation functions
            showLoadingStats() {
                document.getElementById('totalProducts').innerHTML = '<span class="loading-dots">...</span>';
                document.getElementById('pendingOrders').innerHTML = '<span class="loading-dots">...</span>';
                document.getElementById('completedOrders').innerHTML = '<span class="loading-dots">...</span>';
                document.getElementById('deliveredProducts').innerHTML = '<span class="loading-dots">...</span>';
                // Walk-in orders stat will be implemented with database integration
                const walkInElement = document.getElementById('walkInOrders');
                if (walkInElement) walkInElement.innerHTML = '<span class="loading-dots">...</span>';
                document.getElementById('totalRevenue').innerHTML = '<span class="loading-dots">...</span>';
            }
            
            showLoadingProducts() {
                const productsTableBody = document.getElementById('productsTableBody');
                productsTableBody.innerHTML = `
                    <tr>
                        <td colspan="7">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading products...</div>
                            </div>
                        </td>
                    </tr>
                `;
            }
            
            showLoadingOrders() {
                const ordersTableBody = document.getElementById('ordersTableBody');
                ordersTableBody.innerHTML = `
                    <tr>
                        <td colspan="9">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading orders...</div>
                            </div>
                        </td>
                    </tr>
                `;
            }

            showLoadingReturns() {
                const returnsTableBody = document.getElementById('returnsTableBody');
                returnsTableBody.innerHTML = `
                    <tr>
                        <td colspan="8">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading returns...</div>
                            </div>
                        </td>
                    </tr>
                `;
            }
            
            showLoadingRecentActivity() {
                const activityList = document.getElementById('activityList');
                activityList.classList.add('loading');
                activityList.innerHTML = `
                    <div class="loading-spinner">
                        <div class="spinner"></div>
                        <div class="loading-text">Loading recent activity...</div>
                    </div>
                `;
            }

            showLoadingLowStockAlerts() {
                const lowStockList = document.getElementById('lowStockList');
                lowStockList.classList.add('loading');
                lowStockList.innerHTML = `
                    <div class="loading-spinner">
                        <div class="spinner"></div>
                        <div class="loading-text">Loading low stock alerts...</div>
                    </div>
                `;
            }
            
            

            async loadData() {
                // Initialize simple in-memory cache if needed
                if (!this._cache) {
                    this._cache = { products: null, orders: null, returns: null, stats: null };
                }

                // Show loading animations for visible areas
                this.showLoadingStats();
                if (this.currentSection === 'products') this.showLoadingProducts();
                if (this.currentSection === 'orders') this.showLoadingOrders();
                if (this.currentSection === 'returns') this.showLoadingReturns();
                
                // Show loading for dashboard sections if dashboard is the current section
                if (this.currentSection === 'dashboard') {
                    this.showLoadingRecentActivity();
                    this.showLoadingLowStockAlerts();
                }

                // Load the current section's data first (fast first paint),
                // then fetch the remaining datasets in the background
                try {
                    if (this.currentSection === 'products') {
                        await this.loadProducts();
                        this.renderCurrentSection();
                        Promise.allSettled([
                            this.loadOrders(),
                            this.loadReturns(),
                            this.loadComprehensiveStats()
                        ]).then(() => { this.updateStats(); });
                        return;
                    }
                    if (this.currentSection === 'orders') {
                        await this.loadOrders();
                        this.renderCurrentSection();
                        Promise.allSettled([
                            this.loadProducts(),
                            this.loadReturns(),
                            this.loadComprehensiveStats()
                        ]).then(() => { this.updateStats(); });
                        return;
                    }
                    if (this.currentSection === 'returns') {
                        await this.loadReturns();
                        this.renderCurrentSection();
                        Promise.allSettled([
                            this.loadProducts(),
                            this.loadOrders(),
                            this.loadComprehensiveStats()
                        ]).then(() => { this.updateStats(); });
                        return;
                    }
                    // Dashboard needs products + orders + stats primarily
                    await Promise.all([
                        this.loadProducts(),
                        this.loadOrders(),
                        this.loadComprehensiveStats()
                    ]);
                    this.renderCurrentSection();
                    Promise.allSettled([
                        this.loadReturns()
                    ]).then(() => { this.updateStats(); });
                } catch (e) {
                    console.error('Error loading initial data:', e);
                    showToast('Failed to load some data. Please try again.', 'error');
                }
            }
            
            showLoadingProducts() {
                const productsTableBody = document.getElementById('productsTableBody');
                productsTableBody.innerHTML = `
                    <tr>
                        <td colspan="7">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading products...</div>
                            </div>
                        </td>
                    </tr>
                `;
            }
            
            showLoadingOrders() {
                const ordersTableBody = document.getElementById('ordersTableBody');
                ordersTableBody.innerHTML = `
                    <tr>
                        <td colspan="9">
                            <div class="loading-spinner">
                                <div class="spinner"></div>
                                <div class="loading-text">Loading orders...</div>
                            </div>
                        </td>
                    </tr>
                `;
            }
            
            

            // Load comprehensive statistics from all collections
            async loadComprehensiveStats() {
                try {
                    // We'll use a dummy user ID to get overall statistics
                    // In a real system, you might want a dedicated staff statistics endpoint
                    const response = await fetch('http://localhost:3000/api/orders/stats/staff-overview');
                    
                    if (response.ok) {
                        this.comprehensiveStats = await response.json();
                    } else {
                        // Fallback: fetch from all collections manually
                        console.log('üìä Staff Dashboard - Fetching comprehensive stats manually...');
                        await this.loadStatsFromAllCollections();
                    }
                } catch (error) {
                    console.error('Error loading comprehensive stats:', error);
                    await this.loadStatsFromAllCollections();
                }
            }

            // Fallback method to manually fetch stats from all collections
            async loadStatsFromAllCollections() {
                try {
                    // Get orders from all collections
                    const allOrdersResponse = await fetch('http://localhost:3000/api/orders');
                    let allOrders = [];
                    
                    if (allOrdersResponse.ok) {
                        allOrders = await allOrdersResponse.json();
                    }
                    
                    // Count orders by collection and status
                    // Revenue includes both accepted and delivered orders
                    const acceptedOrders = this.orders.filter(o => o.collection === 'accepted');
                    const deliveredOrders = this.orders.filter(o => o.collection === 'delivered');
                    const revenueOrders = [...acceptedOrders, ...deliveredOrders];
                    
                    this.comprehensiveStats = {
                        totalPending: this.orders.filter(o => o.collection === 'pending').length,
                        totalAccepted: acceptedOrders.length,
                        totalDelivered: deliveredOrders.length,
                        totalRevenue: revenueOrders.reduce((sum, order) => {
                            return sum + (parseFloat(order.total) || 0);
                        }, 0)
                    };
                    
                    console.log('üìä Comprehensive stats loaded:', this.comprehensiveStats);
                    console.log('üí∞ Revenue calculated from accepted + delivered orders:', {
                        acceptedOrders: acceptedOrders.length,
                        deliveredOrders: deliveredOrders.length,
                        totalRevenue: this.comprehensiveStats.totalRevenue
                    });
                } catch (error) {
                    console.error('Error loading manual stats:', error);
                    this.comprehensiveStats = {
                        totalPending: this.orders.filter(o => o.collection === 'pending').length,
                        totalAccepted: this.orders.filter(o => o.collection === 'accepted').length,
                        totalDelivered: this.orders.filter(o => o.collection === 'delivered').length,
                        totalRevenue: 0
                    };
                }
            }

            async loadProducts() {
                try {
                    const response = await fetch('http://localhost:3000/api/products');
                    if (!response.ok) throw new Error('Failed to fetch products');

                    let products = await response.json();
                    this.products = products.map(product => ({
                        id: product._id,
                        name: product.name,
                        price: (() => {
                            const toNumber = (val) => {
                                if (val === null || val === undefined) return NaN;
                                if (typeof val === 'object' && val.$numberDecimal !== undefined) return parseFloat(val.$numberDecimal);
                                return parseFloat(val);
                            };
                            const candidates = [product.SellingPrice, product.sellingPrice, product.Price, product.price];
                            for (const c of candidates) {
                                const n = toNumber(c);
                                if (!isNaN(n)) return n;
                            }
                            return 0;
                        })(),
                        category: this.normalizeProductCategory(product.category),
                        image: product.image || 'images/sanrico_logo_1.png',
                        stock: product.stockQuantity || 0,
                        description: product.description || 'No description available.'
                    }));

                    // Debug: Log category distribution
                    console.log('üìä Product category distribution:', this.products.reduce((acc, p) => {
                        acc[p.category] = (acc[p.category] || 0) + 1;
                        return acc;
                    }, {}));
                } catch (error) {
                    console.error('Error loading products:', error);
                    this.products = [];
                }
            }

            async loadOrders() {
                try {
                    // Fetch orders from all collections (pending, accepted, delivered)
                    const response = await fetch('http://localhost:3000/api/orders/all-staff');
                    if (!response.ok) throw new Error('Failed to fetch orders');

                    this.orders = await response.json();
                    console.log('üìä Staff Dashboard - Loaded orders from all collections:', this.orders.length);
                    console.log('üìã Orders breakdown:', {
                        pending: this.orders.filter(o => o.collection === 'pending').length,
                        accepted: this.orders.filter(o => o.collection === 'accepted').length,
                        delivered: this.orders.filter(o => o.collection === 'delivered').length,
                        returned: this.orders.filter(o => o.collection === 'returned').length,
                        walkin: this.orders.filter(o => o.collection === 'walkin').length
                    });

                    // Debug: Log first few orders to see their structure
                    console.log('üîç Sample orders:', this.orders.slice(0, 3).map(o => ({
                        id: o._id?.slice(-6),
                        collection: o.collection,
                        status: o.status,
                        displayStatus: o.displayStatus,
                        orderNumber: o.orderNumber
                    })));

                    this.checkForNewOrders();
                } catch (error) {
                    console.error('Error loading orders:', error);
                    this.orders = [];
                }
            }

            async loadReturns() {
                try {
                    // Fetch returned orders from the returned collection
                    const response = await fetch('http://localhost:3000/api/orders/returns');
                    if (!response.ok) throw new Error('Failed to fetch returns');

                    this.returns = await response.json();
                    console.log('üì¶ Staff Dashboard - Loaded returns:', this.returns.length);

                    // Update returns badge
                    const returnsBadge = document.getElementById('returnsBadge');
                    const pendingReturns = this.returns.filter(r => r.status === 'pending').length;
                    returnsBadge.textContent = pendingReturns;

                    // Update returns nav button title
                    const returnsNavButton = document.getElementById('returnsNavButton');
                    if (pendingReturns === 0) {
                        returnsNavButton.title = 'No return requests';
                    } else {
                        returnsNavButton.title = `${pendingReturns} return request${pendingReturns > 1 ? 's' : ''}`;
                    }

                } catch (error) {
                    console.error('Error loading returns:', error);
                    this.returns = [];
                }
            }

            checkForNewOrders() {
                const storedOrderCount = parseInt(localStorage.getItem('lastOrderCount') || '0');
                const currentOrderCount = this.orders.length;
                
                if (currentOrderCount > storedOrderCount) {
                    const newOrdersCount = currentOrderCount - storedOrderCount;
                    this.addNotification({
                        title: `New Order ${newOrdersCount}`,
                        description: `New orders have been placed`,
                        time: new Date(),
                        type: 'order'
                    });
                }
                
                localStorage.setItem('lastOrderCount', currentOrderCount.toString());
            }

            startOrderPolling() {
                setInterval(async () => {
                    await this.loadOrders();
                    await this.loadComprehensiveStats();
                    this.updateStats();
                    if (this.currentSection === 'orders') {
                        this.renderOrders();
                    }
                }, 30000);
            }

            addNotification(notification) {
                this.notifications.unshift({
                    ...notification,
                    id: Date.now(),
                    read: false
                });
                
                if (this.notifications.length > 50) {
                    this.notifications = this.notifications.slice(0, 50);
                }
                
                localStorage.setItem('staffNotifications', JSON.stringify(this.notifications));
                this.updateNotifications();
                showToast(notification.message, 'info');
            }

            updateNotifications() {
                const badge = document.getElementById('notificationBadge');
                const list = document.getElementById('notificationList');

                if (!badge || !list) {
                    console.error('Notification elements not found');
                    return;
                }

                const unreadCount = this.notifications.filter(n => !n.read).length;
                badge.textContent = unreadCount;
                badge.style.display = unreadCount > 0 ? 'flex' : 'none';

                console.log(`üì¢ Updating notifications: ${this.notifications.length} total, ${unreadCount} unread`);

                if (this.notifications.length === 0) {
                    list.innerHTML = '<div class="no-notifications">No notifications</div>';
                } else {
                    list.innerHTML = this.notifications.map(notification => `
                        <div class="notification-item ${notification.read ? '' : 'unread'}" data-id="${notification.id}" onclick="staffDashboard.markNotificationAsRead('${notification.id}')">
                            <div class="notification-content">
                                <div class="notification-title">${notification.title || 'Notification'}</div>
                                <div class="notification-message">${notification.description || notification.message || 'No message'}</div>
                                <div class="notification-time">${this.formatTime(notification.time)}</div>
                            </div>
                        </div>
                    `).join('');
                }
            }

            formatTime(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;
                
                if (diff < 60000) return 'Just now';
                if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
                if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
                return date.toLocaleDateString();
            }

            // Updated product category normalization to match server-side logic
            normalizeProductCategory(productCategory) {
                if (!productCategory) return 'other';

                const category = String(productCategory).toLowerCase();
                const includesAny = (list) => list.some(keyword => category.includes(keyword));

                // Comprehensive category mapping based on server logic
                if (includesAny(['paint','painting'])) return 'paints';
                if (includesAny(['power-tools','powertools','hand-tools','handtools','tool','tools','accessor'])) return 'tools-accessories';
                if (includesAny(['building-materials','aggregate','cement','sand','gravel','hollow','plywood','wood','lumber','tile','roof'])) return 'building-materials-aggregates';
                if (includesAny(['electrical','wire','breaker','outlet','switch'])) return 'electrical-supplies';
                if (includesAny(['plumbing','fixture','pipe','fitting','faucet','valve'])) return 'plumbing-fixtures';
                if (includesAny(['fastener','screw','nail','bolt','nut','consumable','adhesive','sealant','tape'])) return 'fasteners-consumables';

                // Legacy category mappings for backward compatibility
                switch (String(productCategory)) {
                    case 'Power-Tools':
                    case 'Hand-Tools':
                        return 'tools-accessories';
                    case 'Building-Materials':
                        return 'building-materials-aggregates';
                    case 'Plumbing':
                        return 'plumbing-fixtures';
                    case 'Electrical':
                        return 'electrical-supplies';
                    default:
                        return 'other';
                }
            }

            formatCategoryName(category) {
                switch(category) {
                    case 'power-tools': return 'Power Tools';
                    case 'hand-tools': return 'Hand Tools';
                    case 'building-materials': return 'Building Materials';
                    case 'plumbing': return 'Plumbing';
                    case 'electrical': return 'Electrical';
                    default: return category.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                }
            }

            updateStats() {
                document.getElementById('totalProducts').textContent = this.products.length;
                
                // Use comprehensive stats if available, otherwise fall back to local calculations
                if (this.comprehensiveStats) {
                    // Count orders by their actual status in the database using comprehensive stats
                    const pendingOrders = this.comprehensiveStats.totalPending || this.orders.filter(order => {
                        const status = order.status?.toLowerCase();
                        return status === 'active' || status === 'pending';
                    }).length;
                    
                    const acceptedOrders = this.comprehensiveStats.totalAccepted || this.orders.filter(order => {
                        return order.collection === 'accepted' || order.displayStatus === 'approved';
                    }).length;
                    
                    const deliveredOrders = this.comprehensiveStats.totalDelivered || 0;
                    
                    // Calculate total revenue including walk-in orders from database
                    const totalRevenue = this.orders
                        .filter(order => {
                            // Include accepted, delivered, and walk-in orders for revenue calculation
                            return order.collection === 'accepted' || order.collection === 'delivered' || 
                                   order.collection === 'walkin' ||
                                   order.displayStatus === 'approved' || order.displayStatus === 'delivered' ||
                                   order.displayStatus === 'completed';
                        })
                        .reduce((sum, order) => sum + (parseFloat(order.total) || 0), 0);
                    
                    // Calculate walk-in orders count from database
                    const walkInOrders = this.orders.filter(order => {
                        return order.collection === 'walkin' || order.displayStatus === 'completed';
                    }).length;
                    
                    // Update walk-in orders display
                    const walkInElement = document.getElementById('walkInOrders');
                    if (walkInElement) {
                        walkInElement.textContent = walkInOrders;
                    }
                    
                    // Calculate total delivered products (individual items, not orders)
                    const deliveredProducts = this.orders
                        .filter(order => order.collection === 'delivered' || order.displayStatus === 'delivered')
                        .reduce((total, order) => {
                            const orderItems = order.itemsordered || [];
                            const orderProductCount = orderItems.reduce((orderTotal, item) => {
                                return orderTotal + (parseInt(item.amount_per_item) || 0);
                            }, 0);
                            return total + orderProductCount;
                        }, 0);
                    
                    // Calculate orders requiring action (pending + accepted)
                    const ordersRequiringAction = pendingOrders + acceptedOrders;
                    
                    document.getElementById('pendingOrders').textContent = pendingOrders;
                    document.getElementById('completedOrders').textContent = deliveredOrders;
                    document.getElementById('deliveredProducts').textContent = deliveredProducts;
                    
                    // Update badge with actionable orders count or "0 action/s required"
                    const ordersBadge = document.getElementById('ordersBadge');
                    ordersBadge.textContent = ordersRequiringAction;
                    
                    // Update tooltip text dynamically on the nav button
                    const ordersNavButton = document.getElementById('ordersNavButton');
                    if (ordersRequiringAction === 0) {
                        ordersNavButton.title = 'No actions required';
                    } else {
                        ordersNavButton.title = `${ordersRequiringAction} action${ordersRequiringAction > 1 ? 's' : ''} required`;
                    }
                    
                    document.getElementById('totalRevenue').textContent = formatPrice(totalRevenue);
                } else {
                    // Fallback to local calculations
                    const pendingOrders = this.orders.filter(order => {
                        const status = order.status?.toLowerCase();
                        return status === 'active' || status === 'pending';
                    }).length;
                    
                    const acceptedOrders = this.orders.filter(order => {
                        return order.collection === 'accepted' || order.displayStatus === 'approved';
                    }).length;
                    
                    const completedOrders = this.orders.filter(order => {
                        const status = order.status?.toLowerCase();
                        return status === 'completed' || status === 'delivered';
                    }).length;
                    
                    // Calculate total delivered products (individual items, not orders) - fallback
                    const deliveredProducts = this.orders
                        .filter(order => {
                            const status = order.status?.toLowerCase();
                            return status === 'completed' || status === 'delivered' || 
                                   order.collection === 'delivered' || order.displayStatus === 'delivered';
                        })
                        .reduce((total, order) => {
                            const orderItems = order.itemsordered || [];
                            const orderProductCount = orderItems.reduce((orderTotal, item) => {
                                return orderTotal + (parseInt(item.amount_per_item) || 0);
                            }, 0);
                            return total + orderProductCount;
                        }, 0);
                    
                    const totalRevenue = this.orders
                        .filter(order => {
                            // Include accepted, delivered, and walk-in orders for revenue calculation
                            return order.collection === 'accepted' || order.collection === 'delivered' || 
                                   order.collection === 'walkin' ||
                                   order.displayStatus === 'approved' || order.displayStatus === 'delivered' ||
                                   order.displayStatus === 'completed';
                        })
                        .reduce((sum, order) => sum + (parseFloat(order.total) || 0), 0);
                    
                    // Calculate walk-in orders count
                    const walkInOrders = this.orders.filter(order => {
                        return order.collection === 'walkin' || order.displayStatus === 'completed';
                    }).length;
                    
                    // Update walk-in orders display if element exists
                    const walkInElement = document.getElementById('walkInOrders');
                    if (walkInElement) {
                        walkInElement.textContent = walkInOrders;
                    }
                    
                    // Calculate orders requiring action (pending + accepted)
                    const ordersRequiringAction = pendingOrders + acceptedOrders;
                    
                    document.getElementById('pendingOrders').textContent = pendingOrders;
                    document.getElementById('completedOrders').textContent = completedOrders;
                    document.getElementById('deliveredProducts').textContent = deliveredProducts;
                    
                    // Update badge with actionable orders count or "0 action/s required"
                    const ordersBadge = document.getElementById('ordersBadge');
                    ordersBadge.textContent = ordersRequiringAction;
                    
                    // Update tooltip text dynamically on the nav button
                    const ordersNavButton = document.getElementById('ordersNavButton');
                    if (ordersRequiringAction === 0) {
                        ordersNavButton.title = 'No actions required';
                    } else {
                        ordersNavButton.title = `${ordersRequiringAction} action${ordersRequiringAction > 1 ? 's' : ''} required`;
                    }
                    
                    document.getElementById('totalRevenue').textContent = formatPrice(totalRevenue);
                }
                
                // Note: Walk-in orders will be loaded from database in future update
                // Removed problematic references to non-existent HTML elements
            }

            initializeEventListeners() {
                // Sidebar navigation
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        this.switchSection(e.currentTarget.dataset.section);
                    });
                });

                // Clickable stat cards navigation
                document.querySelectorAll('.stat-card.clickable').forEach(card => {
                    card.addEventListener('click', (e) => {
                        const section = e.currentTarget.dataset.section;
                        this.switchSection(section);
                    });
                });

                // Notification events
                const notificationBtn = document.getElementById('notificationBtn');
                if (notificationBtn) {
                    // Add debugging to ensure button is clickable
                    console.log('‚úÖ Notification button found:', notificationBtn);
                    console.log('‚úÖ Button style:', window.getComputedStyle(notificationBtn));
                    console.log('‚úÖ Button z-index:', window.getComputedStyle(notificationBtn).zIndex);
                    console.log('‚úÖ Button pointer-events:', window.getComputedStyle(notificationBtn).pointerEvents);

                    notificationBtn.addEventListener('click', (e) => {
                        console.log('üîî Notification button clicked');
                        e.preventDefault();
                        e.stopImmediatePropagation();

                        const dropdown = document.getElementById('notificationDropdown');
                        if (dropdown) {
                            const isCurrentlyShown = dropdown.classList.contains('show');
                            console.log('üìã Current dropdown state:', isCurrentlyShown);

                            if (isCurrentlyShown) {
                                dropdown.classList.remove('show');
                                console.log('üìã Notification dropdown hidden');
                            } else {
                                dropdown.classList.add('show');
                                console.log('üìã Notification dropdown shown');
                            }
                        } else {
                            console.error('‚ùå Notification dropdown not found');
                        }
                    });

                    // Prevent the global click handler from interfering
                    notificationBtn.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                    });



                    console.log('‚úÖ Notification button event listener attached');
                } else {
                    console.error('‚ùå Notification button not found');
                }

                // Close notification dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    const notificationBtn = document.getElementById('notificationBtn');
                    const notificationDropdown = document.getElementById('notificationDropdown');

                    // Only close if the click is NOT on the button or dropdown
                    if (notificationBtn && notificationDropdown &&
                        !notificationBtn.contains(e.target) &&
                        !notificationDropdown.contains(e.target)) {
                        console.log('üìã Closing dropdown due to outside click');
                        notificationDropdown.classList.remove('show');
                    }
                });

                // Dashboard events
                document.getElementById('refreshDashboard').addEventListener('click', () => {
                    this.showLoadingStats();
                    this.loadData();
                    showToast('Dashboard refreshed', 'success');
                });

                // Low stock alerts "View All" button
                document.getElementById('navigateToLowStockProducts').addEventListener('click', () => {
                    this.switchSection('products');
                    // Optional: Filter to show only low stock products
                    setTimeout(() => {
                        // This would filter the products to show low stock items
                        // For now, just switch to products section
                    }, 150);
                });

                // Product management events
                document.getElementById('categoryFilter').addEventListener('change', () => {
                    this.currentPage = 1;
                    this.renderProducts();
                });

                document.getElementById('productSearch').addEventListener('input', () => {
                    this.currentPage = 1;
                    this.renderProducts();
                });

                // Order management events
                document.getElementById('orderStartDate').addEventListener('change', () => {
                    this.renderOrders();
                });

                document.getElementById('orderEndDate').addEventListener('change', () => {
                    this.renderOrders();
                });

                document.getElementById('orderStatusFilter').addEventListener('change', () => {
                    this.renderOrders();
                });

                document.getElementById('paymentMethodFilter').addEventListener('change', () => {
                    this.renderOrders();
                });

                document.getElementById('refreshOrdersBtn').addEventListener('click', async () => {
                    this.showLoadingOrders();
                    await this.loadOrders();
                    this.renderOrders();
                    showToast('Orders refreshed', 'success');
                });

                // Order search functionality
                document.getElementById('orderSearch').addEventListener('input', () => {
                    this.currentPage = 1;
                    this.renderOrders();
                });

                // Returns refresh functionality
                document.getElementById('refreshReturnsBtn').addEventListener('click', async () => {
                    this.showLoadingReturns();
                    await this.loadReturns();
                    this.renderReturns();
                    showToast('Returns refreshed', 'success');
                });

                // Date dropdown functionality
                document.getElementById('dateDropdownBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dropdown = document.getElementById('dateDropdown');
                    const btn = e.currentTarget;
                    
                    dropdown.classList.toggle('show');
                    btn.classList.toggle('active');
                });

                document.getElementById('dateDropdownClose').addEventListener('click', () => {
                    this.closeDateDropdown();
                });

                document.getElementById('clearDatesBtn').addEventListener('click', () => {
                    document.getElementById('orderStartDate').value = '';
                    document.getElementById('orderEndDate').value = '';
                    this.renderOrders();
                    this.closeDateDropdown();
                });

                document.getElementById('applyDatesBtn').addEventListener('click', () => {
                    this.renderOrders();
                    this.closeDateDropdown();
                });

                // Close date dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    const dropdown = document.getElementById('dateDropdown');
                    const btn = document.getElementById('dateDropdownBtn');
                    
                    if (!dropdown.contains(e.target) && !btn.contains(e.target)) {
                        this.closeDateDropdown();
                    }
                });

                // POS events
                this.initializePOSEvents();

                // Modal events
                this.initializeModalEvents();

                // Logout
                document.getElementById('logoutBtn').addEventListener('click', () => {
                    handleLogout();
                });

                // Removed duplicate event listeners - using the ones below

                document.getElementById('changeToDenied').addEventListener('click', () => {
                    this.showOrderDenialDialog();
                });

                // Setup order denial dialog
                this.setupOrderDenialDialog();
                this.setupOrderApprovalDialog();
                this.setupOrderDeliveryDialog();
                this.setupOrderReturnDialog();
            }

            initializePOSEvents() {
                // POS product search
                document.getElementById('posProductSearch').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.handlePOSSearch();
                    }
                });

                // Real-time search input handling
                document.getElementById('posProductSearch').addEventListener('input', (e) => {
                    this.handlePOSSearchInput(e);
                });

                document.getElementById('scanProductBtn').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.handlePOSSearch();
                });

                // POS category filters
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        // Clear search when switching categories
                        this.currentSearchQuery = '';
                        document.getElementById('posProductSearch').value = '';
                        this.hidePOSSearchDropdown();
                        
                        this.currentCategory = e.target.dataset.category;
                        this.renderPOSProducts(this.currentCategory || 'all');
                    });
                });

                // Cart actions
                document.getElementById('clearCartBtn').addEventListener('click', () => {
                    this.clearCart();
                });

                document.getElementById('newTransactionBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleNewTransactionDropdown();
                });

                // New transaction dropdown events
                document.getElementById('newTransactionClose').addEventListener('click', () => {
                    this.closeNewTransactionDropdown();
                });

                document.getElementById('cancelNewTransaction').addEventListener('click', () => {
                    this.closeNewTransactionDropdown();
                });

                document.getElementById('startNewTransaction').addEventListener('click', () => {
                    this.startNewTransaction();
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    const dropdown = document.getElementById('newTransactionDropdown');
                    const container = document.querySelector('.new-transaction-container');
                    
                    if (dropdown && container && !container.contains(e.target)) {
                        this.closeNewTransactionDropdown();
                    }
                });

                document.getElementById('checkoutBtn').addEventListener('click', () => {
                    this.showPaymentModal();
                });

                // Payment modal events
                document.getElementById('paymentModalClose').addEventListener('click', () => {
                    document.getElementById('paymentModal').classList.remove('show');
                });

                document.getElementById('cancelPayment').addEventListener('click', () => {
                    document.getElementById('paymentModal').classList.remove('show');
                });

                document.getElementById('confirmPayment').addEventListener('click', () => {
                    this.processPayment();
                });

                document.getElementById('amountReceived').addEventListener('input', () => {
                    this.calculateChange();
                });

                // Payment method change
                document.querySelectorAll('input[name="paymentMethod"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        const cashPayment = document.getElementById('cashPayment');
                        if (e.target.value === 'cash') {
                            cashPayment.style.display = 'block';
                        } else {
                            cashPayment.style.display = 'none';
                        }
                    });
                });
            }

            initializeModalEvents() {
                // Product modal
                document.getElementById('productModalClose').addEventListener('click', () => {
                    document.getElementById('productModal').classList.remove('show');
                });

                document.getElementById('cancelEdit').addEventListener('click', () => {
                    document.getElementById('productModal').classList.remove('show');
                });

                document.getElementById('saveProduct').addEventListener('click', () => {
                    this.saveProductChanges();
                });

                // Order modal
                document.getElementById('orderModalClose').addEventListener('click', () => {
                    document.getElementById('orderModal').classList.remove('show');
                });

                document.getElementById('closeOrderModal').addEventListener('click', () => {
                    document.getElementById('orderModal').classList.remove('show');
                });

                // Status change buttons event listeners
                document.getElementById('changeToPending').addEventListener('click', () => {
                    this.updateOrderStatus('pending');
                });

                document.getElementById('changeToApproved').addEventListener('click', () => {
                    this.showOrderApprovalDialog();
                });

                document.getElementById('changeToDelivered').addEventListener('click', () => {
                    this.showOrderDeliveryDialog();
                });

                document.getElementById('changeToReturned').addEventListener('click', () => {
                    this.showOrderReturnDialog();
                });

                document.getElementById('changeToDenied').addEventListener('click', () => {
                    this.showOrderDenialDialog();
                });

                

                // File upload
                document.getElementById('dropZone').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });

                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFileSelect(e.target.files[0]);
                    }
                });

                document.getElementById('removeImageBtn').addEventListener('click', () => {
                    this.removeImage();
                });
            }

            switchSection(section) {
                // Update navigation
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-section="${section}"]`).classList.add('active');

                // Update sections
                document.querySelectorAll('.content-section').forEach(sec => {
                    sec.classList.remove('active');
                });
                document.getElementById(`${section}-section`).classList.add('active');

                this.currentSection = section;
                this.currentPage = 1;
                this.renderCurrentSection();
            }

            renderCurrentSection() {
                // Show brief loading when switching sections
                if (this.currentSection === 'products') {
                    this.showLoadingProducts();
                    this.renderProducts();
                } else if (this.currentSection === 'orders') {
                    this.showLoadingOrders();
                    this.renderOrders();
                } else if (this.currentSection === 'returns') {
                    this.showLoadingReturns();
                    this.renderReturns();
                } else if (this.currentSection === 'dashboard') {
                    // Show loading for dashboard sections when switching to dashboard
                    this.showLoadingRecentActivity();
                    this.showLoadingLowStockAlerts();
                    this.renderDashboard();
                } else {
                    // No loading for cashier section
                    switch(this.currentSection) {
                        case 'cashier':
                            this.renderPOSProducts('all');
                            break;
                    }
                }
            }

            renderDashboard() {
                // Render recent activity and low stock alerts
                // Loading is already shown during loadData() if this is the initial load
                this.renderRecentActivity();
                this.renderLowStockAlerts();
            }

            renderRecentActivity() {
                const activityList = document.getElementById('activityList');
                activityList.classList.remove('loading');

                // Show recent orders for activity
                const recentActivities = [
                    ...this.orders.slice(0, 5).map(order => ({
                        type: 'order',
                        orderId: order._id,
                        title: `New Order ${order.orderNumber || this.generateOrderNumber(order)}`,
                        description: `${order.fullName || order.buyerinfo || 'Unknown Customer'} - ${formatPrice(order.total) || 0}`,
                        time: new Date(order.createdAt || order.orderDate || order.original_date)
                    }))
                ].sort((a, b) => b.time - a.time).slice(0, 5);

                if (recentActivities.length === 0) {
                    activityList.innerHTML = '<div class="no-data">No recent activity</div>';
                    return;
                }

                activityList.innerHTML = recentActivities.map(activity => `
                    <div class="activity-item" data-order-id="${activity.orderId}" onclick="staffDashboard.viewOrder('${activity.orderId}')">
                        <div class="activity-icon ${activity.type}">
                            ${activity.type === 'order' ? 'üìã' : 'üö∂'}
                        </div>
                        <div class="activity-content">
                            <div class="activity-title">${activity.title}</div>
                            <div class="activity-description">${activity.description}</div>
                            <div class="activity-time">${this.formatTime(activity.time)}</div>
                        </div>
                        <div class="activity-arrow">
                            <i class="fa fa-chevron-right"></i>
                        </div>
                    </div>
                `).join('');
            }

            renderLowStockAlerts() {
                const lowStockList = document.getElementById('lowStockList');
                lowStockList.classList.remove('loading');

                // Filter products with low stock (5 or less)
                const lowStockProducts = this.products.filter(product => product.stock <= 5).slice(0, 5);

                if (lowStockProducts.length === 0) {
                    lowStockList.innerHTML = '<div class="no-data">All products are well stocked ‚úÖ</div>';
                    return;
                }

                lowStockList.innerHTML = lowStockProducts.map(product => `
                    <div class="low-stock-item" onclick="staffDashboard.editProduct('${product.id}')">
                        <div class="low-stock-image">
                            <img src="${product.image.startsWith('data:image') ? product.image : 'images/' + product.image}"
                                 alt="${product.name}"
                                 onerror="this.src='images/sanrico_logo_1.png'">
                            <div class="low-stock-image-overlay">
                                ${product.stock === 0 ? 'OUT' : product.stock <= 2 ? 'CRITICAL' : 'LOW'}
                            </div>
                        </div>
                        <div class="low-stock-content">
                            <div class="low-stock-product-name">${product.name}</div>
                            <div class="low-stock-category">${this.formatCategoryName(product.category)}</div>
                        </div>
                        <div class="low-stock-details">
                            <div class="low-stock-quantity-summary">
                                <span class="quantity-label">Stock:</span>
                                <span class="stock-count ${product.stock === 0 ? 'out-of-stock' : product.stock <= 2 ? 'critical-stock' : 'low-stock'}">${product.stock}</span>
                            </div>
                        </div>
                    </div>
                `).join('');
            }

            renderProducts() {
                const tbody = document.getElementById('productsTableBody');
                const categoryFilter = document.getElementById('categoryFilter').value;
                const searchQuery = document.getElementById('productSearch').value.toLowerCase();
                
                let filteredProducts = this.products;
                
                if (categoryFilter !== 'all') {
                    filteredProducts = filteredProducts.filter(p => p.category === categoryFilter);
                }
                
                if (searchQuery) {
                    filteredProducts = filteredProducts.filter(p => 
                        p.name.toLowerCase().includes(searchQuery)
                    );
                }
                
                const start = (this.currentPage - 1) * this.itemsPerPage;
                const end = start + this.itemsPerPage;
                const displayed = filteredProducts.slice(start, end);

                if (displayed.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" class="no-data">No products found</td></tr>';
                    return;
                }

                tbody.innerHTML = displayed.map(product => `
                    <tr>
                        <td>
                            <div class="product-image-cell">
                                <img src="${product.image.startsWith('data:image') ? product.image : 'images/' + product.image}" 
                                     alt="${product.name}" 
                                     onerror="this.src='images/sanrico_logo_1.png'"
                                     class="product-table-image">
                            </div>
                        </td>
                        <td>
                            <div class="product-name-cell">
                                <strong>${product.name}</strong>
                            </div>
                        </td>
                        <td>
                            <span class="category-badge">${this.formatCategoryName(product.category)}</span>
                        </td>
                        <td>
                            <span class="product-price-cell">‚Ç±${formatPrice(product.price)}</span>
                        </td>
                        <td>
                            <span class="stock-quantity ${product.stock === 0 ? 'stock-out' : product.stock <= 5 ? 'stock-low' : 'stock-in'}">${product.stock}</span>
                        </td>
                        <td>
                            <span class="stock-status ${product.stock === 0 ? 'out-of-stock' : product.stock <= 5 ? 'low-stock' : 'in-stock'}">
                                ${product.stock === 0 ? 'Out of Stock' : product.stock <= 5 ? 'Low Stock' : 'In Stock'}
                            </span>
                        </td>
                        <td>
                            <button class="action-btn small primary" onclick="staffDashboard.editProduct('${product.id}')">Edit</button>
                        </td>
                    </tr>
                `).join('');

                this.updatePagination('productsPagination', filteredProducts.length);
            }

            renderOrders() {
                const tbody = document.getElementById('ordersTableBody');
                const statusFilter = document.getElementById('orderStatusFilter').value;
                const paymentFilter = document.getElementById('paymentMethodFilter').value;
                const startDate = document.getElementById('orderStartDate').value;
                const endDate = document.getElementById('orderEndDate').value;
                
                console.log('üîç Rendering orders with filter:', statusFilter);
                console.log('üìä Total orders before filtering:', this.orders.length);
                
                let filteredOrders = this.orders;
                
                // Filter by search query first
                const searchQuery = document.getElementById('orderSearch').value.toLowerCase().trim();
                if (searchQuery) {
                    filteredOrders = filteredOrders.filter(o => {
                        const customerName = (o.fullName || o.buyerinfo || '').toLowerCase();
                        const orderNumber = (o.orderNumber || this.generateOrderNumber(o)).toLowerCase();
                        const orderIdShort = o._id ? o._id.slice(-6).toLowerCase() : '';
                        
                        return customerName.includes(searchQuery) || 
                               orderNumber.includes(searchQuery) || 
                               orderIdShort.includes(searchQuery);
                    });
                }
                
                // Filter by status - use displayStatus for accurate filtering
                if (statusFilter !== 'all') {
                    filteredOrders = filteredOrders.filter(o => {
                        const displayStatus = o.displayStatus || o.status;
                        const matches = displayStatus === statusFilter;
                        if (!matches) {
                            console.log(`‚ùå Order ${o._id?.slice(-6)} filtered out: displayStatus="${displayStatus}", filter="${statusFilter}"`);
                        }
                        return matches;
                    });
                }
                
                console.log('üìä Orders after status filtering:', filteredOrders.length);
                
                // Filter by payment method
                if (paymentFilter !== 'all') {
                    console.log('üîç Filtering by payment method:', paymentFilter);
                    filteredOrders = filteredOrders.filter(o => (o.paymentMethod || 'cod') === paymentFilter);
                    console.log('üìä Orders after payment filtering:', filteredOrders.length);
                }
                
                // Filter by date range
                if (startDate) {
                    console.log('üîç Filtering by start date:', startDate);
                    const beforeDateFilter = filteredOrders.length;
                    filteredOrders = filteredOrders.filter(o => {
                        const orderDate = new Date(o.createdAt || o.orderDate || o.original_date);
                        const isValid = orderDate >= new Date(startDate);
                        if (!isValid) {
                            console.log(`‚ùå Order ${o._id?.slice(-6)} filtered out by start date: orderDate="${orderDate}", startDate="${startDate}"`);
                        }
                        return isValid;
                    });
                    console.log(`üìä Orders after start date filtering: ${beforeDateFilter} ‚Üí ${filteredOrders.length}`);
                }
                
                if (endDate) {
                    console.log('üîç Filtering by end date:', endDate);
                    const beforeDateFilter = filteredOrders.length;
                    filteredOrders = filteredOrders.filter(o => {
                        const orderDate = new Date(o.createdAt || o.orderDate || o.original_date);
                        const isValid = orderDate <= new Date(endDate + 'T23:59:59');
                        if (!isValid) {
                            console.log(`‚ùå Order ${o._id?.slice(-6)} filtered out by end date: orderDate="${orderDate}", endDate="${endDate}"`);
                        }
                        return isValid;
                    });
                    console.log(`üìä Orders after end date filtering: ${beforeDateFilter} ‚Üí ${filteredOrders.length}`);
                }
                
                const start = (this.currentPage - 1) * this.itemsPerPage;
                const end = start + this.itemsPerPage;
                const displayed = filteredOrders.slice(start, end);

                if (displayed.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="9" class="no-data">No orders found</td></tr>';
                    return;
                }

                tbody.innerHTML = displayed.map(order => {
                    // Determine the correct status display based on collection and status
                    let statusDisplay = order.displayStatus || order.status;
                    let statusClass = statusDisplay;
                    
                    // Map status classes for CSS
                    if (statusDisplay === 'pending' || order.status === 'active') {
                        statusClass = 'pending';
                        statusDisplay = 'Pending';
                    } else if (statusDisplay === 'approved') {
                        statusClass = 'approved';
                        statusDisplay = 'Approved';
                    } else if (statusDisplay === 'delivered') {
                        statusClass = 'delivered';
                        statusDisplay = 'Delivered';
                    } else if (statusDisplay === 'returned') {
                        statusClass = 'returned';
                        statusDisplay = 'Returned';
                    } else if (statusDisplay === 'completed' || order.collection === 'walkin') {
                        statusClass = 'completed';
                        statusDisplay = 'Walk-in/Completed';
                    }
                    
                    return `
                        <tr data-collection="${order.collection || 'unknown'}">
                            <td>${order.orderNumber || this.generateOrderNumber(order)}</td>
                            <td>${order.fullName || order.buyerinfo || 'N/A'}</td>
                            <td>${(order.itemsordered || []).length} items</td>
                            <td>‚Ç±${order.total.toFixed(2)}</td>
                            <td>
                                <span class="payment-method ${order.paymentMethod || 'cod'}">
                                    ${this.formatPaymentMethod(order.paymentMethod || 'cod')}
                                </span>
                                ${order.paymentType === 'split' && order.collection !== 'delivered' ? `
                                    <div style="margin-top: 0.25rem; font-size: 0.75rem; color: #d32f2f; font-weight: 500;">
                                        üí∞ Balance: ‚Ç±${formatPrice((parseFloat(order.total) || 0) - (parseFloat(order.paymentAmount) || 0))}
                                    </div>
                                ` : ''}
                            </td>
                            <td>
                                <span class="shipping-info">
                                    ${order.address ? 'Delivery' : 'Pickup'}
                                </span>
                            </td>
                            <td>${new Date(order.orderDate || order.createdAt || order.original_date).toLocaleString()}</td>
                            <td>
                                <span class="status-badge ${statusClass.toLowerCase()}">
                                    ${statusDisplay}
                                </span>
                            </td>
                            <td>
                                <button class="action-btn small" onclick="staffDashboard.viewOrder('${order._id}')">View</button>
                            </td>
                        </tr>
                    `;
                }).join('');

                this.updatePagination('ordersPagination', filteredOrders.length);
            }

            // renderWalkInOrders() - Disabled until database integration
            // TODO: Implement with WalkInOrders database collection
            renderWalkInOrders() {
                console.log('Walk-in orders rendering disabled - will be implemented with database integration');
                return;
                /*
                const tbody = document.getElementById('walkInOrdersTableBody');

                if (this.walkInOrders.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" class="no-data">No walk-in orders found</td></tr>';
                    return;
                }

                const sortedOrders = [...this.walkInOrders].sort((a, b) => new Date(b.date) - new Date(a.date));

                tbody.innerHTML = sortedOrders.map(order => `
                    <tr>
                        <td>#${order.id.toString().slice(-6)}</td>
                        <td>${order.customerName}</td>
                        <td>${order.items.length} items</td>
                        <td>‚Ç±${order.total.toFixed(2)}</td>
                        <td>
                            <span class="payment-method ${order.paymentMethod}">
                                ${this.formatPaymentMethod(order.paymentMethod)}
                            </span>
                        </td>
                        <td>${new Date(order.date).toLocaleString()}</td>
                        <td>
                            <button class="action-btn small" onclick="staffDashboard.viewWalkInOrder('${order.id}')">View</button>
                        </td>
                    </tr>
                `).join('');
                */
            }

            renderReturns() {
                const tbody = document.getElementById('returnsTableBody');
                const statusFilter = document.getElementById('returnStatusFilter').value;

                console.log('üîÑ Rendering returns with filter:', statusFilter);
                console.log('üì¶ Total returns available:', this.returns.length);

                let filteredReturns = this.returns;

                // Filter by status
                if (statusFilter !== 'all') {
                    filteredReturns = filteredReturns.filter(r => r.status === statusFilter);
                    console.log('üì¶ Returns after status filtering:', filteredReturns.length);
                }

                // Sort by request date (newest first)
                filteredReturns.sort((a, b) => new Date(b.requestDate || b.createdAt) - new Date(a.requestDate || a.createdAt));

                const start = (this.currentPage - 1) * this.itemsPerPage;
                const end = start + this.itemsPerPage;
                const displayed = filteredReturns.slice(start, end);

                if (displayed.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" class="no-data">No return requests found</td></tr>';
                    return;
                }

                tbody.innerHTML = displayed.map(returnRequest => {
                    const orderNumber = returnRequest.orderNumber || this.generateOrderNumber(returnRequest);
                    const customerName = returnRequest.fullName || returnRequest.buyerinfo || 'N/A';
                    const requestDate = new Date(returnRequest.requestDate || returnRequest.createdAt || returnRequest.original_date).toLocaleString();
                    const status = returnRequest.status || 'pending';
                    const returnType = returnRequest.returnType || 'Return';
                    const reason = returnRequest.returnReason || 'No reason provided';
                    const itemsCount = (returnRequest.itemsordered || []).length;

                    return `
                        <tr>
                            <td>${orderNumber}</td>
                            <td>${customerName}</td>
                            <td>
                                <span class="return-type-badge">${returnType}</span>
                            </td>
                            <td>
                                <div class="return-reason-cell" title="${reason}">
                                    ${reason.length > 30 ? reason.substring(0, 30) + '...' : reason}
                                </div>
                            </td>
                            <td>${itemsCount} item${itemsCount !== 1 ? 's' : ''}</td>
                            <td>${requestDate}</td>
                            <td>
                                <span class="status-badge ${status.toLowerCase()}">
                                    ${status.charAt(0).toUpperCase() + status.slice(1)}
                                </span>
                            </td>
                            <td>
                                <button class="action-btn small" onclick="staffDashboard.viewReturn('${returnRequest._id}')">View</button>
                                ${status === 'pending' ? `
                                    <button class="action-btn small primary" onclick="staffDashboard.processReturn('${returnRequest._id}')">Process</button>
                                ` : ''}
                            </td>
                        </tr>
                    `;
                }).join('');

                this.updatePagination('returnsPagination', filteredReturns.length);
            }

            renderPOSProducts(category = 'all') {
                console.log('üì¶ renderPOSProducts called with category:', category);
                console.log('üì¶ Total products available:', this.products.length);
                
                this.currentCategory = category;
                
                // If there's an active search, use filterPOSProducts instead
                if (this.currentSearchQuery) {
                    console.log('üì¶ Using filterPOSProducts due to active search');
                    this.filterPOSProducts();
                    return;
                }
                
                const grid = document.getElementById('posProductsGrid');
                console.log('üì¶ Found grid element:', !!grid);
                
                let filteredProducts = this.products.filter(p => p.stock > 0);
                console.log('üì¶ Products with stock > 0:', filteredProducts.length);
                
                if (category !== 'all') {
                    filteredProducts = filteredProducts.filter(p => p.category === category);
                    console.log('üì¶ Products after category filter:', filteredProducts.length);
                }

                // Sort by newest first (if available)
                filteredProducts.sort((a, b) => {
                    if (a.createdAt && b.createdAt) {
                        return new Date(b.createdAt) - new Date(a.createdAt);
                    }
                    return b.id.localeCompare(a.id);
                });

                if (filteredProducts.length === 0) {
                    console.log('üì¶ No products available - showing no-data message');
                    grid.innerHTML = '<div class="no-data">No products available</div>';
                    return;
                }

                console.log('üì¶ Rendering', filteredProducts.length, 'products');
                console.log('üì¶ Sample product IDs:', filteredProducts.slice(0, 3).map(p => p.id));

                grid.innerHTML = filteredProducts.map(product => `
                    <div class="pos-product-card" onclick="staffDashboard.addToCart('${product.id}')">
                        <div class="pos-product-image">
                            <img src="${product.image.startsWith('data:image') ? product.image : 'images/' + product.image}" 
                                 alt="${product.name}" 
                                 onerror="this.src='images/sanrico_logo_1.png'">
                        </div>
                        <div class="pos-product-info">
                            <h4>${product.name}</h4>
                            <div class="pos-product-price">‚Ç±${formatPrice(product.price)}</div>
                            <div class="pos-product-stock">Stock: ${product.stock}</div>
                        </div>
                    </div>
                `).join('');
                
                console.log('üì¶ Products rendered successfully');
            }

            // POS Methods

            filterPOSProducts() {
                const grid = document.getElementById('posProductsGrid');
                const category = this.currentCategory || 'all';
                const query = this.currentSearchQuery || '';
                
                let filteredProducts = this.products.filter(p => p.stock > 0);
                
                // Filter by category
                if (category !== 'all') {
                    filteredProducts = filteredProducts.filter(p => p.category === category);
                }
                
                // Filter by search query
                if (query) {
                    filteredProducts = filteredProducts.filter(p => 
                        p.name.toLowerCase().includes(query.toLowerCase())
                    );
                }

                // Sort by newest first
                filteredProducts.sort((a, b) => {
                    if (a.createdAt && b.createdAt) {
                        return new Date(b.createdAt) - new Date(a.createdAt);
                    }
                    return b.id.localeCompare(a.id);
                });

                if (filteredProducts.length === 0) {
                    grid.innerHTML = '<div class="no-data">No products found</div>';
                    return;
                }

                grid.innerHTML = filteredProducts.map(product => `
                    <div class="pos-product-card" onclick="staffDashboard.addToCart('${product.id}')">
                        <div class="pos-product-image">
                            <img src="${product.image.startsWith('data:image') ? product.image : 'images/' + product.image}"
                                 alt="${product.name}"
                                 onerror="this.src='images/sanrico_logo_1.png'">
                        </div>
                        <div class="pos-product-info">
                            <h4>${product.name}</h4>
                            <div class="pos-product-price">‚Ç±${formatPrice(product.price)}</div>
                            <div class="pos-product-stock">Stock: ${product.stock}</div>
                        </div>
                    </div>
                `).join('');
            }

            addToCart(productId) {
                if (!this.currentTransaction) {
                    showToast('Start a new transaction before adding products.', 'warning');
                    return;
                }
                console.log('üõí addToCart called with productId:', productId);
                console.log('üõí Available products:', this.products.length);
                console.log('üõí Current cart length:', this.cart.length);
                
                const product = this.products.find(p => p.id === productId);
                console.log('üõí Found product:', product);
                
                if (!product || product.stock === 0) {
                    console.log('üõí Product not available or out of stock');
                    showToast('Product not available', 'error');
                    return;
                }

                const existingItem = this.cart.find(item => item.id === productId);
                if (existingItem) {
                    if (existingItem.quantity < product.stock) {
                        existingItem.quantity++;
                        console.log('üõí Updated existing item quantity to:', existingItem.quantity);
                    } else {
                        console.log('üõí Insufficient stock for existing item');
                        showToast('Insufficient stock', 'error');
                        return;
                    }
                } else {
                    this.cart.push({
                        ...product,
                        quantity: 1
                    });
                    console.log('üõí Added new item to cart. Cart length now:', this.cart.length);
                }

                this.updateCartDisplay();
                showToast(`${product.name} added to cart`, 'success');
            }

            updateCartDisplay() {
                const cartItems = document.getElementById('cartItems');
                const cartCount = document.getElementById('cartCount');
                const checkoutBtn = document.getElementById('checkoutBtn');
                
                if (this.cart.length === 0) {
                    cartItems.innerHTML = '<div class="empty-cart"><p>No items in order</p></div>';
                    cartCount.textContent = '0 items';
                    checkoutBtn.disabled = true;
                } else {
                    const totalItems = this.cart.reduce((sum, item) => sum + item.quantity, 0);
                    cartCount.textContent = `${totalItems} item${totalItems > 1 ? 's' : ''}`;
                    checkoutBtn.disabled = false;
                    
                    cartItems.innerHTML = this.cart.map((item, index) => `
                        <div class="order-item">
                            <div class="order-item-image">
                                <img src="${item.image.startsWith('data:image') ? item.image : 'images/' + item.image}" 
                                     alt="${item.name}" 
                                     onerror="this.src='images/sanrico_logo_1.png'">
                            </div>
                            <div class="order-item-details">
                                <div class="order-item-name">${item.name}</div>
                                <div class="order-item-price">‚Ç±${formatPrice(item.price)} each</div>
                                <div class="order-item-stock">Stock: ${item.stock}</div>
                            </div>
                            <div class="order-item-controls">
                                <div class="quantity-controls">
                                    <button class="qty-btn decrease" onclick="staffDashboard.updateCartQuantity(${index}, -1)" title="Decrease quantity">
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                    <span class="quantity-display">${item.quantity}</span>
                                    <button class="qty-btn increase" onclick="staffDashboard.updateCartQuantity(${index}, 1)" title="Increase quantity">
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                </div>
                                <div class="order-item-total">${formatPrice(item.price * item.quantity)}</div>
                                <button class="remove-item-btn" onclick="staffDashboard.removeFromCart(${index})" title="Remove item">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    `).join('');
                }

                this.updateCartTotals();
            }

            updateCartQuantity(index, change) {
                const item = this.cart[index];
                const newQuantity = item.quantity + change;
                
                if (newQuantity <= 0) {
                    this.removeFromCart(index);
                } else if (newQuantity <= item.stock) {
                    item.quantity = newQuantity;
                    this.updateCartDisplay();
                } else {
                    showToast('Insufficient stock', 'error');
                }
            }

            removeFromCart(index) {
                this.cart.splice(index, 1);
                this.updateCartDisplay();
            }

            clearCart() {
                this.cart = [];
                this.updateCartDisplay();
            }

            updateCartTotals() {
                const subtotal = this.cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
                const total = subtotal;

                document.getElementById('subtotal').textContent = formatPrice(subtotal);
                document.getElementById('total').textContent = formatPrice(total);
            }

            showPaymentModal() {
                if (this.cart.length === 0) return;

                const total = this.cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
                document.getElementById('paymentTotal').textContent = `‚Ç±${total.toFixed(2)}`;
                document.getElementById('amountReceived').value = '';
                document.getElementById('changeAmount').textContent = '‚Ç±0.00';
                document.getElementById('paymentModal').classList.add('show');
            }

            calculateChange() {
                const total = parseFloat(document.getElementById('paymentTotal').textContent.replace('‚Ç±', ''));
                const received = parseFloat(document.getElementById('amountReceived').value) || 0;
                const change = received - total;
                document.getElementById('changeAmount').textContent = `‚Ç±${Math.max(0, change).toFixed(2)}`;
            }

            async processPayment() {
                const paymentMethod = document.querySelector('input[name="paymentMethod"]:checked').value;
                const total = parseFloat(document.getElementById('paymentTotal').textContent.replace('‚Ç±', ''));
                
                if (paymentMethod === 'cash') {
                    const received = parseFloat(document.getElementById('amountReceived').value) || 0;
                    if (received < total) {
                        showToast('Insufficient amount received', 'error');
                        return;
                    }
                }

                // Get current transaction info
                const transactionInfo = this.getCurrentCustomerInfo();
                const customerName = transactionInfo.customerName || 'Walk-in Customer';
                const orderId = transactionInfo.orderId;
                
                // Get payment method from the payment modal (where user actually selects it)
                const selectedPaymentMethod = document.querySelector('input[name="paymentMethod"]:checked').value;

                // Prepare walk-in order data with all required fields
                const walkInOrderData = {
                    orderNumber: orderId || 'N/A',
                    fullName: customerName || 'N/A',
                    email: 'N/A',
                    phoneNumber: 'N/A',
                    address: 'N/A',
                    itemsordered: this.cart.map(item => ({
                        item_id: item.id || 'N/A',
                        item_name: item.name || 'N/A',
                        price_per_item: item.price || 0,
                        amount_per_item: item.quantity || 0,
                        total_item_price: (item.price * item.quantity) || 0
                    })),
                    subtotal: this.cart.reduce((sum, item) => sum + (item.price * item.quantity), 0),
                    total: total,
                    paymentMethod: selectedPaymentMethod || 'cash',
                    paymentReference: 'N/A',
                    paymentAmount: total,
                    proofOfPayment: 'N/A',
                    paymentVerified: true,
                    status: 'completed',
                    displayStatus: 'completed',
                    collection: 'walkin',
                    source: 'pos_walkin',
                    notes: 'Walk-in order completed via POS',
                    createdAt: new Date().toISOString(),
                    orderDate: new Date().toISOString(),
                    original_date: new Date().toISOString(),
                    userId: 'N/A',
                    staffId: Auth.getCurrentUser()?.staffId || 'Unknown Staff',
                    type: 'walkin'
                };

                try {
                    // Save to WalkInOrders collection
                    const response = await fetch('http://localhost:3000/api/orders/walkin', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(walkInOrderData)
                    });

                    if (!response.ok) {
                        throw new Error('Failed to save walk-in order');
                    }

                    const result = await response.json();
                    console.log('‚úÖ Walk-in order saved successfully:', result);

                    // --- ACTUAL STOCK UPDATE IN DATABASE ---
                    const stockUpdates = this.cart.map(item => ({
                        id: item.id,
                        quantity: item.quantity
                    }));
                    try {
                        const stockResponse = await fetch('http://localhost:3000/api/products/bulk-stock', {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ updates: stockUpdates })
                        });
                        if (!stockResponse.ok) {
                            throw new Error('Failed to update product stock');
                        }
                        console.log('‚úÖ Product stock updated in database');
                    } catch (stockErr) {
                        console.error('‚ùå Error updating product stock:', stockErr);
                        showToast('Order saved, but failed to update product stock!', 'warning');
                    }
                    // --- END STOCK UPDATE ---

                    // Update product stock locally
                    this.cart.forEach(item => {
                        const product = this.products.find(p => p.id === item.id);
                        if (product) {
                            product.stock -= item.quantity;
                        }
                    });

                    // Close payment modal
                    document.getElementById('paymentModal').classList.remove('show');
                    
                    // Clear cart and reset transaction
                    this.cart = [];
                    this.updateCartDisplay();
                    this.currentTransaction = null;
                    this.updateCustomerInfoDisplay('', '', '');
                    
                    // Show success toast
                    showToast('Order complete! Sending data to database...', 'success');
                    
                    // Add notification for successful transaction
                    this.addNotification({
                        title: '‚úÖ Successful Walk-in Transaction',
                        description: `Order ${orderId} completed for ${customerName} - ‚Ç±${total.toFixed(2)}`,
                        time: new Date(),
                        type: 'transaction_success'
                    });
                    
                    // Update stats
                    this.updateStats();
                    
                } catch (error) {
                    console.error('‚ùå Error saving walk-in order:', error);
                    showToast('Order completed but failed to save to database', 'warning');
                    
                    // Still clear the cart and reset transaction even if save failed
                    this.cart = [];
                    this.updateCartDisplay();
                    this.currentTransaction = null;
                    this.updateCustomerInfoDisplay('', '', '');
                }
            }

            // Utility Methods
            formatPaymentMethod(method) {
                switch(method) {
                    case 'cash': return 'Cash';
                    case 'gcash': return 'GCash';
                    case 'bank': return 'Bank Transfer';
                    case 'cheque': return 'Cheque';
                    default: return 'Unknown';
                }
            }

            updatePagination(containerId, totalItems) {
                const container = document.getElementById(containerId);
                const totalPages = Math.ceil(totalItems / this.itemsPerPage);
                
                if (totalPages <= 1) {
                    container.innerHTML = '';
                    return;
                }

                container.innerHTML = '';
                for (let i = 1; i <= totalPages; i++) {
                    const button = document.createElement('button');
                    button.textContent = i;
                    button.className = `page-btn ${i === this.currentPage ? 'active' : ''}`;
                    button.onclick = () => {
                        this.currentPage = i;
                        this.renderCurrentSection();
                    };
                    container.appendChild(button);
                }
            }

            // Product Management Methods
            editProduct(id) {
                const product = this.products.find(p => p.id === id);
                if (!product) return;
                
                this.currentEditingProduct = product;
                
                document.getElementById('productName').value = product.name;
                document.getElementById('productStock').value = product.stock;
                
                if (product.image && !product.image.includes('sanrico_logo_1.png')) {
                    const previewImg = document.getElementById('previewImg');
                    const imagePreview = document.getElementById('imagePreview');
                    const removeBtn = document.getElementById('removeImageBtn');
                    
                    previewImg.src = product.image.startsWith('data:image') ? product.image : 'images/' + product.image;
                    imagePreview.classList.remove('hidden');
                    removeBtn.classList.remove('hidden');
                }
                
                document.getElementById('productModal').classList.add('show');
            }

            async saveProductChanges() {
                if (!this.currentEditingProduct) return;
                
                try {
                    const stock = parseInt(document.getElementById('productStock').value);
                    const previewImg = document.getElementById('previewImg');
                    
                    const updateData = {
                        stockQuantity: stock
                    };
                    
                    if (previewImg.src && !previewImg.src.includes('sanrico_logo_1.png')) {
                        updateData.image = previewImg.src;
                    }
                    
                    const response = await fetch(`http://localhost:3000/api/products/${this.currentEditingProduct.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updateData)
                    });
                    
                    if (!response.ok) throw new Error('Failed to update product');
                    
                    const productIndex = this.products.findIndex(p => p.id === this.currentEditingProduct.id);
                    if (productIndex !== -1) {
                        this.products[productIndex].stock = stock;
                        if (updateData.image) {
                            this.products[productIndex].image = updateData.image;
                        }
                    }
                    
                    document.getElementById('productModal').classList.remove('show');
                    this.renderProducts();
                    showToast('Product updated successfully', 'success');
                } catch (error) {
                    console.error('Error updating product:', error);
                    showToast('Failed to update product', 'error');
                }
            }

            // Order Management Methods
            viewOrder(orderId) {
                const order = this.orders.find(o => o._id === orderId);
                if (!order) return;
                
                this.currentEditingOrder = order;
                
                // Populate order ID and date with improved formatting
                const orderNumber = order.orderNumber || this.generateOrderNumber(order);
                document.getElementById('staffModalOrderId').textContent = orderNumber;
                document.getElementById('staffModalOrderDate').textContent = new Date(order.orderDate || order.createdAt || order.original_date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // Resolve delivery address if it's an address ID
                this.resolveDeliveryAddress(order).then((resolvedAddress) => {
                    // Populate customer information with resolved address
                const customerInfo = document.getElementById('staffCustomerInfo');
                customerInfo.innerHTML = `
                    <div class="info-row">
                        <span class="info-label">Customer Name</span>
                        <span class="info-value">${order.fullName || order.buyerinfo || 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Email</span>
                        <span class="info-value">${order.email || 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Phone</span>
                        <span class="info-value">${order.phoneNumber || 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Delivery Address</span>
                            <span class="info-value">${resolvedAddress || 'Pickup'}</span>
                    </div>
                    ${order.notes && order.notes !== 'no additional notes' ? `
                        <div class="info-row">
                            <span class="info-label">Notes</span>
                            <span class="info-value">${order.notes}</span>
                        </div>
                    ` : ''}
                `;
                });
                
                // Populate order items with modern styling
                const itemsList = document.getElementById('staffModalOrderItems');
                itemsList.innerHTML = (order.itemsordered || []).map(item => `
                    <div class="order-item-modern">
                        <div class="item-info-modern">
                            <div class="item-name-modern">${item.item_name || 'Unknown Item'}</div>
                            <div class="item-details-modern">Qty: ${item.amount_per_item || 1} √ó ${formatPrice(item.price_per_item) || '‚Ç±0.00'}</div>
                        </div>
                        <div class="item-total-modern">${formatPrice(item.total_item_price) || '‚Ç±0.00'}</div>
                    </div>
                `).join('');
                
                // Calculate and populate totals
                const subtotal = parseFloat(order.subtotal) || (order.itemsordered || []).reduce((total, item) => total + (parseFloat(item.total_item_price) || 0), 0);
                const deliveryFee = parseFloat(order.deliveryFee) || 0;
                const total = parseFloat(order.total) || (subtotal + deliveryFee);

                document.getElementById('staffModalSubtotal').textContent = formatPrice(subtotal);
                document.getElementById('staffModalDeliveryFee').textContent = formatPrice(deliveryFee);
                document.getElementById('staffModalTotal').textContent = formatPrice(total);
                
                // Populate staff technical information with better formatting
                const technicalInfo = document.getElementById('staffOrderTechnicalInfo');
                technicalInfo.innerHTML = `
                    <div class="info-row">
                        <span class="info-label">Database ID</span>
                        <span class="info-value technical-value">${order._id || 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">User ID</span>
                        <span class="info-value technical-value">${order.userId || 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Created At</span>
                        <span class="info-value">${order.createdAt || order.original_date ? new Date(order.createdAt || order.original_date).toLocaleString() : 'N/A'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Order Source</span>
                        <span class="info-value">${order.source || 'checkout_page'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Current Status</span>
                        <span class="info-value">
                            <span class="staff-status-badge ${(order.status || 'pending').toLowerCase()}">${order.status || 'Pending'}</span>
                        </span>
                    </div>
                `;
                
                // Populate payment or return information based on order status
                const paymentInfo = document.getElementById('staffPaymentInfo');
                const isReturnedOrder = order.collection === 'returned' || order.displayStatus === 'returned';
                const isWalkInOrder = order.collection === 'walkin' || order.displayStatus === 'completed';
                
                // Update section title based on order type
                const sectionTitle = paymentInfo.closest('.order-card-section').querySelector('.section-title');
                if (isReturnedOrder) {
                    sectionTitle.textContent = 'Return Information';
                } else if (isWalkInOrder) {
                    sectionTitle.textContent = 'Transaction Information';
                } else {
                    sectionTitle.textContent = 'Payment Information';
                }
                
                if (isReturnedOrder) {
                    // Display return information
                    const hasReturnImage = order.returnImage && order.returnImage.trim() !== '';
                    
                    paymentInfo.innerHTML = `
                        <div class="payment-method-modern">
                            <div class="payment-icon">‚Ü©Ô∏è</div>
                            <div>
                                <strong>Order Returned</strong>
                                ${order.returnedAt ? `<div style="font-size: 0.85rem; color: #666;">Processed: ${new Date(order.returnedAt).toLocaleString()}</div>` : ''}
                                ${order.returnProcessedBy ? `<div style="font-size: 0.85rem; color: #666;">Processed by: ${order.returnProcessedBy}</div>` : ''}
                            </div>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Return Reason</span>
                            <span class="info-value">${order.returnReason || 'No reason provided'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Return Documentation</span>
                            <span class="info-value">
                                ${hasReturnImage ? 
                                    `<span style="color: #28a745; font-weight: 500;">‚úì Image Available</span>
                                     <button type="button" class="proof-preview-btn" onclick="staffDashboard.showReturnImagePreview('${order.returnImage}')">
                                         <i class="fa fa-eye"></i> View Return Image
                                     </button>` : 
                                    `<span style="color: #dc3545; font-weight: 500;">‚ö† No Image Uploaded</span>`
                                }
                            </span>
                        </div>
                        ${order.returnImageUploadedAt ? `
                            <div class="info-row">
                                <span class="info-label">Image Uploaded</span>
                                <span class="info-value">${new Date(order.returnImageUploadedAt).toLocaleString()}</span>
                            </div>
                        ` : ''}
                    `;
                } else if (isWalkInOrder) {
                    // Display walk-in transaction information (no payment verification needed)
                    paymentInfo.innerHTML = `
                        <div class="payment-method-modern">
                            <div class="payment-icon">üè™</div>
                            <div>
                                <strong>Walk-in Transaction</strong>
                                <div style="font-size: 0.85rem; color: #666;">Payment Method: ${this.formatPaymentMethod(order.paymentMethod || 'cash')}</div>
                                ${order.paymentAmount ? `<div style="font-size: 0.85rem; color: #666;">Amount: ‚Ç±${parseFloat(order.paymentAmount).toFixed(2)}</div>` : ''}
                            </div>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Transaction Status</span>
                            <span class="info-value">
                                <span style="color: #28a745; font-weight: 500;">‚úì Completed at POS</span>
                            </span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Transaction Type</span>
                            <span class="info-value">Walk-in Purchase (No delivery required)</span>
                        </div>
                        ${order.staffId ? `
                            <div class="info-row">
                                <span class="info-label">Processed by</span>
                                <span class="info-value">${order.staffId}</span>
                            </div>
                        ` : ''}
                    `;
                } else {
                    // Display payment information (original logic for online orders)
                    const hasProofOfPayment = order.proofOfPayment && order.proofOfPayment.trim() !== '';
                    
                    paymentInfo.innerHTML = `
                        <div class="payment-method-modern">
                            <div class="payment-icon">üí≥</div>
                            <div>
                                <strong>${this.formatPaymentMethod(order.paymentMethod || 'cod')}</strong>
                                ${order.paymentType ? `<div style="font-size: 0.85rem; color: #666;">Type: ${order.paymentType === 'full' ? 'Full Payment' : 'Split Payment'}</div>` : ''}
                                ${order.paymentSplitPercent ? `<div style="font-size: 0.85rem; color: #666;">Split: ${order.paymentSplitPercent}%</div>` : ''}
                                ${order.paymentReference ? `<div style="font-size: 0.85rem; color: #666;">Ref: ${order.paymentReference}</div>` : ''}
                                ${order.paymentAmount ? `<div style="font-size: 0.85rem; color: #666;">Amount: ‚Ç±${parseFloat(order.paymentAmount).toFixed(2)}</div>` : ''}
                                ${order.changeUponDelivery ? `<div style="font-size: 0.85rem; color: #28a745;">‚úì Change upon delivery</div>` : ''}
                            </div>
                        </div>
                        ${order.paymentType === 'split' ? `
                            <div class="info-row" style="background: #fff3e0; padding: 1rem; border-radius: 8px; border-left: 4px solid #ff9800; margin: 1rem 0;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                                    <span style="font-weight: 600; color: #e65100;">üí∞ Split Payment Details</span>
                                    <span style="display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px; border-radius: 50%; background: #fff; color: #6b7280; font-size: 11px; font-weight: 700; border: 1px solid #d1d5db; cursor: help; user-select: none;" title="This order uses split payment. The customer has already paid a portion, and the remaining balance must be collected upon delivery.">?</span>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.75rem;">
                                    <div style="padding: 0.75rem; background: #e3f2fd; border-radius: 6px; border-left: 3px solid #2196f3;">
                                        <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.25rem;">Already Paid</div>
                                        <div style="font-size: 1rem; font-weight: 600; color: #1976d2;">‚Ç±${(parseFloat(order.paymentAmount) || 0).toFixed(2)}</div>
                                        <div style="font-size: 0.75rem; color: #666;">${order.paymentSplitPercent || 0}% of total</div>
                                    </div>
                                    <div style="padding: 0.75rem; background: #ffebee; border-radius: 6px; border-left: 3px solid #f44336;">
                                        <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.25rem;">Balance to Collect</div>
                                        <div style="font-size: 1rem; font-weight: 600; color: #d32f2f;">‚Ç±${((parseFloat(order.total) || 0) - (parseFloat(order.paymentAmount) || 0)).toFixed(2)}</div>
                                        <div style="font-size: 0.75rem; color: #666;">${100 - (parseFloat(order.paymentSplitPercent) || 0)}% of total</div>
                                    </div>
                                </div>
                                <div style="padding: 0.75rem; background: #e8f5e8; border-radius: 6px; border-left: 3px solid #4caf50;">
                                    <div style="font-size: 0.85rem; color: #2e7d32;">
                                        <strong>üìã Collection Instructions:</strong> Collect the "Balance to Collect" amount upon delivery. ${order.changeUponDelivery ? 'Customer may pay with larger amount and receive change.' : 'Exact amount required.'}
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                        <div class="info-row">
                            <span class="info-label">Payment Status</span>
                            <span class="info-value">
                                ${hasProofOfPayment ? 
                                    `<span style="color: #28a745; font-weight: 500;">‚úì Proof Available</span>
                                     <button type="button" class="proof-preview-btn" onclick="staffDashboard.showProofPreview('${order.proofOfPayment}')">
                                         <i class="fa fa-eye"></i> Preview Proof
                                     </button>` : 
                                    `<span style="color: #dc3545; font-weight: 500;">‚ö† No Proof Uploaded</span>`
                                }
                            </span>
                        </div>
                        ${order.paymentVerified !== undefined ? `
                            <div class="info-row">
                                <span class="info-label">Payment Verified</span>
                                <span class="info-value">
                                    <span class="staff-status-badge ${order.paymentVerified ? 'completed' : 'pending'}">
                                        ${order.paymentVerified ? 'Verified' : 'Pending Verification'}
                                    </span>
                                </span>
                            </div>
                        ` : ''}
                    `;
                }
                
                // Update button visibility based on current order status
                this.updateStatusButtonVisibility(order);
                document.getElementById('orderModal').classList.add('show');
            }

            // Update button visibility and states based on current order status
            updateStatusButtonVisibility(order) {
                const currentStatus = order.status === 'active' ? 'pending' : (order.status || 'pending');
                const effectiveStatus = order.collection === 'accepted' || order.displayStatus === 'approved' ? 'approved' :
                                      order.collection === 'delivered' || order.displayStatus === 'delivered' ? 'delivered' : 
                                      order.collection === 'walkin' || order.displayStatus === 'completed' ? 'completed' : currentStatus;
                
                const pendingBtn = document.getElementById('changeToPending');
                const approvedBtn = document.getElementById('changeToApproved');
                const deliveredBtn = document.getElementById('changeToDelivered');
                const returnedBtn = document.getElementById('changeToReturned');
                const deniedBtn = document.getElementById('changeToDenied');
                
                // Hide all buttons first
                [pendingBtn, approvedBtn, deliveredBtn, returnedBtn, deniedBtn].forEach(btn => {
                    if (btn) {
                        btn.style.display = 'none';
                        btn.disabled = false;
                        btn.title = '';
                        btn.style.opacity = '1';
                    }
                });
                
                // Walk-in orders are already completed - no status changes allowed
                if (effectiveStatus === 'completed') {
                    return; // No buttons shown for walk-in orders
                }
                
                // Show buttons based on current status for other order types
                if (effectiveStatus === 'pending') {
                    // Pending orders: Show "Change to Denied" first, then "Change to Approved"
                    if (deniedBtn) deniedBtn.style.display = 'inline-block';
                    if (approvedBtn) approvedBtn.style.display = 'inline-block';
                } else if (effectiveStatus === 'approved') {
                    // Approved orders: Show only "Change to Delivered"
                    if (deliveredBtn) deliveredBtn.style.display = 'inline-block';
                } else if (effectiveStatus === 'delivered') {
                    // Delivered orders: Show only "Change to Returned"
                    if (returnedBtn) returnedBtn.style.display = 'inline-block';
                }
                // For other statuses (denied, returned, etc.), no buttons are shown
            }

            // New method to resolve delivery address IDs to readable addresses
            async resolveDeliveryAddress(order) {
                try {
                    if (!order.delivery_address) {
                        return null;
                    }
                    
                    // If it's already a string (not an ID), return as is
                    if (typeof order.delivery_address === 'string' && !order.delivery_address.match(/^[0-9a-fA-F]{24}$/)) {
                        return order.delivery_address;
                    }
                    
                    // Try to resolve the address ID
                    const response = await fetch(`/api/addresses/${order.delivery_address}`);
                    if (response.ok) {
                        const address = await response.json();
                        return address.fullAddress || address.address;
                    } else {
                        console.log('Address not found, using original value');
                        return order.delivery_address;
                    }
                } catch (error) {
                    console.error('Error resolving delivery address:', error);
                    return order.delivery_address;
                }
            }

            async updateOrderStatus(newStatus, denialReason = '') {
                if (!this.currentEditingOrder) return;
                
                try {
                    const currentStatus = this.currentEditingOrder.status;
                    const order = this.currentEditingOrder;
                    
                    // Check if the status is already set to the selected value
                    // Map 'active' to 'pending' for comparison
                    const normalizedCurrentStatus = currentStatus === 'active' ? 'pending' : currentStatus;
                    
                    if (normalizedCurrentStatus === newStatus) {
                        const statusDisplayName = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
                        showToast(`Order is already ${statusDisplayName}`, 'warning');
                        return;
                    }
                    
                    // Validate status transitions
                    if (!this.isValidStatusTransition(normalizedCurrentStatus, newStatus)) {
                        showToast('Invalid status transition', 'error');
                        return;
                    }
                    
                    // Determine target collection and operation
                    let targetCollection;
                    let moveOperation;
                    
                    switch (newStatus) {
                        case 'pending':
                            targetCollection = 'orders';
                            moveOperation = 'moveToPending';
                            break;
                        case 'approved':
                            targetCollection = 'accepted';
                            moveOperation = 'moveToAccepted';
                            break;
                        case 'delivered':
                            targetCollection = 'delivered';
                            moveOperation = 'moveToDelivered';
                            break;
                        case 'returned':
                            targetCollection = 'returned';
                            moveOperation = 'moveToReturned';
                            break;
                        case 'denied':
                            targetCollection = 'denied';
                            moveOperation = 'moveToDenied';
                            break;
                        default:
                            showToast('Invalid status', 'error');
                            return;
                    }
                    
                    // Prepare request body
                    const requestBody = {
                        orderId: order._id,
                        operation: moveOperation,
                        fromCollection: this.getOrderCollection(order),
                        toCollection: targetCollection
                    };
                    
                    // Add denial reason if provided
                    if (newStatus === 'denied' && denialReason) {
                        requestBody.denialReason = denialReason;
                    }
                    
                    // Make API call to update status
                    const response = await fetch('http://localhost:3000/api/orders/move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        let successMessage = `Order status updated to ${newStatus}`;
                        if (newStatus === 'denied' && denialReason) {
                            successMessage += ` (Reason: ${denialReason})`;
                        }
                        showToast(successMessage, 'success');
                        
                        // Close modal and refresh orders
                        document.getElementById('orderModal').classList.remove('show');
                        this.currentEditingOrder = null;
                        
                        // Refresh the orders list
                        await this.loadOrders();
                        this.renderOrders();
                        
                    } else {
                        const errorData = await response.text();
                        console.error('Error updating order status:', errorData);
                        showToast('Failed to update order status', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error updating order status:', error);
                    showToast('Failed to update order status', 'error');
                }
            }

            isValidStatusTransition(currentStatus, newStatus) {
                const transitions = {
                    'pending': ['approved', 'denied'],
                    'approved': ['delivered'],
                    'delivered': ['returned']
                };
                
                return transitions[currentStatus] && transitions[currentStatus].includes(newStatus);
            }

            getOrderCollection(order) {
                if (order.collection) return order.collection;
                if (order.displayStatus === 'delivered') return 'delivered';
                if (order.displayStatus === 'approved') return 'accepted';
                return 'orders';
            }

            // Additional helper methods for order management
            async moveOrderToAccepted(order) {
                return this.updateOrderStatus('approved');
            }

            async moveOrderToDelivered(order) {
                return this.updateOrderStatus('delivered');
            }

            // Method to show proof of payment preview
            showProofPreview(proofUrl) {
                if (!proofUrl) {
                    showToast('No proof of payment available', 'warning');
                    return;
                }
                
                // Create a modal to show the proof image
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>Proof of Payment</h2>
                            <button type="button" class="modal-close" onclick="this.closest('.modal').remove()">√ó</button>
                        </div>
                        <div style="text-align: center; padding: 1rem;">
                            <img src="${proofUrl}" alt="Proof of Payment" style="max-width: 100%; max-height: 500px; border-radius: 8px;">
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
            }

            // Method to show return image preview
            showReturnImagePreview(imageUrl) {
                if (!imageUrl) {
                    showToast('No return image available', 'warning');
                    return;
                }
                
                // Create a modal to show the return image
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>Return Documentation Image</h2>
                            <button type="button" class="modal-close" onclick="this.closest('.modal').remove()">√ó</button>
                        </div>
                        <div style="text-align: center; padding: 1rem;">
                            <img src="${imageUrl}" alt="Return Documentation" style="max-width: 100%; max-height: 500px; border-radius: 8px;">
                        </div>
                        <div style="text-align: center; padding: 0 1rem 1rem; color: #666; font-size: 0.9rem;">
                            This image was uploaded as documentation for the order return.
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
            }

            generateOrderNumber(order) {
                if (order.orderNumber) return order.orderNumber;
                return `ORD-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
            }

            formatPaymentMethod(method) {
                switch(method) {
                    case 'cash': return 'Cash';
                    case 'gcash': return 'GCash';
                    case 'bank': return 'Bank Transfer';
                    case 'cheque': return 'Cheque';
                    case 'cod': return 'Cash on Delivery';
                    default: return method ? method.charAt(0).toUpperCase() + method.slice(1) : 'Cash';
                }
            }

            // Cancel Transaction Method
            cancelTransaction() {
                // Check if there's an active transaction
                if (!this.currentTransaction && this.cart.length === 0) {
                    showToast('No active transaction to cancel', 'warning');
                    return;
                }
                
                // Clear the cart
                this.cart = [];
                this.updateCartDisplay();
                
                // Reset customer info display
                this.updateCustomerInfoDisplay('', '', '');
                
                // Store the cancelled transaction info for the message
                const cancelledOrderId = this.currentTransaction ? this.currentTransaction.orderId : '';
                
                // Clear current transaction
                this.currentTransaction = null;
                
                // Show success message
                const message = cancelledOrderId ? 
                    `Transaction ${cancelledOrderId} cancelled` : 
                    'Transaction cancelled';
                showToast(message, 'info');
            }

            // Additional methods that might be missing...
            
            generateTransactionOrderId() {
                // Use same format as database orderNumber: ORD-{timestamp}-{random}
                const timestamp = Date.now();
                const random = Math.floor(Math.random() * 1000);
                
                return `ORD-${timestamp}-${random}`;
            }

            getCurrentCustomerInfo() {
                if (this.currentTransaction) {
                    return {
                        orderId: this.currentTransaction.orderId,
                        customerName: this.currentTransaction.customerName,
                        paymentMethod: this.currentTransaction.paymentMethod,
                        isWalkIn: this.currentTransaction.isWalkIn || false
                    };
                }
                
                return {
                    orderId: '',
                    customerName: '',
                    paymentMethod: 'cash',
                    isWalkIn: false
                };
            }

            updateCustomerInfoDisplay(customerName, paymentMethod, orderId, isWalkIn = false) {
                const displayElement = document.getElementById('customerInfoDisplay');
                const textElement = displayElement.querySelector('.customer-display-text');
                
                if (orderId) {
                    const paymentText = this.formatPaymentMethod(paymentMethod);
                    let displayText;
                    
                    if (isWalkIn) {
                        displayText = `${orderId} - ${customerName} (walk-in)`;
                    } else {
                        displayText = `${orderId} - ${customerName} (${paymentText})`;
                    }
                    
                    textElement.textContent = displayText;
                    displayElement.classList.add('customer-info-set');
                } else {
                    textElement.textContent = 'No transaction started';
                    displayElement.classList.remove('customer-info-set');
                }
            }

            startNewTransaction() {
                const customerName = document.getElementById('newTransactionCustomerName').value.trim();
                const orderId = document.getElementById('newTransactionOrderId').textContent;
                
                // Generate random userId if customer name is empty
                let finalCustomerName = customerName;
                let isWalkIn = false;
                
                if (!customerName) {
                    finalCustomerName = Date.now().toString(); // Generate timestamp-based userId
                    isWalkIn = true;
                }
                
                // Clear the cart
                this.cart = [];
                this.updateCartDisplay();
                
                // Update customer info display with order ID and customer info (no payment method)
                this.updateCustomerInfoDisplay(finalCustomerName, '', orderId, isWalkIn);
                
                // Store current transaction info
                this.currentTransaction = {
                    orderId: orderId,
                    customerName: finalCustomerName,
                    isWalkIn: isWalkIn,
                    startTime: new Date()
                };
                
                // Close dropdown
                this.closeNewTransactionDropdown();
                
                // Show success message
                const displayText = isWalkIn ? `${finalCustomerName} (walk-in)` : finalCustomerName;
                showToast(`${orderId} started for ${displayText}`, 'success');
            }

            showNewTransactionDropdown() {
                const dropdown = document.getElementById('newTransactionDropdown');
                const button = document.getElementById('newTransactionBtn');
                
                // Generate new order ID
                const orderId = this.generateTransactionOrderId();
                document.getElementById('newTransactionOrderId').textContent = orderId;
                
                // Clear form fields
                document.getElementById('newTransactionCustomerName').value = '';
                
                dropdown.classList.add('show');
                button.classList.add('active');
                
                // Focus on customer name field
                setTimeout(() => {
                    document.getElementById('newTransactionCustomerName').focus();
                }, 100);
            }

            closeNewTransactionDropdown() {
                const dropdown = document.getElementById('newTransactionDropdown');
                const button = document.getElementById('newTransactionBtn');
                
                dropdown.classList.remove('show');
                button.classList.remove('active');
            }

            toggleNewTransactionDropdown() {
                const dropdown = document.getElementById('newTransactionDropdown');
                
                if (dropdown.classList.contains('show')) {
                    this.closeNewTransactionDropdown();
                } else {
                    this.showNewTransactionDropdown();
                }
            }

            // Close date dropdown function
            closeDateDropdown() {
                const dropdown = document.getElementById('dateDropdown');
                const button = document.getElementById('dateDropdownBtn');
                
                if (dropdown) dropdown.classList.remove('show');
                if (button) button.classList.remove('active');
            }

            // Setup order denial dialog
            setupOrderDenialDialog() {
                const dialog = document.getElementById('orderDenialDialog');
                
                // Add event listener for dialog close
                dialog.addEventListener('close', () => {
                    if (dialog.returnValue === 'confirm') {
                        const denialReason = document.getElementById('denialReason').value.trim();
                        this.proceedWithOrderDenial(denialReason);
                    }
                    // Clear the textarea for next use
                    document.getElementById('denialReason').value = '';
                });
            }

            // Setup order approval dialog
            setupOrderApprovalDialog() {
                const dialog = document.getElementById('orderApprovalDialog');
                
                // Add event listener for dialog close
                dialog.addEventListener('close', async () => {
                    if (dialog.returnValue === 'confirm') {
                        try {
                            // STEP 1: Deduct stock from products BEFORE moving order
                            await this.deductStockForOrder(this.currentEditingOrder);
                            
                            // STEP 2: Send notification to the user about order approval
                            this.sendOrderApprovalNotification(this.currentEditingOrder);
                            
                            // STEP 3: Update order status to approved
                            this.updateOrderStatus('approved');
                        } catch (error) {
                            console.error('Error during order approval process:', error);
                            showToast('Failed to approve order: ' + error.message, 'error');
                        }
                    }
                });
            }

            // Setup order delivery dialog
            setupOrderDeliveryDialog() {
                const dialog = document.getElementById('orderDeliveryDialog');
                
                // Prevent duplicate listeners by checking if already set up
                if (dialog.dataset.setupComplete === 'true') {
                    return;
                }
                dialog.dataset.setupComplete = 'true';
                
                // Add event listener for dialog close
                dialog.addEventListener('close', () => {
                    if (dialog.returnValue === 'confirm') {
                        // Send notification to the user about order delivery
                        this.sendOrderDeliveryNotification(this.currentEditingOrder);
                        // Update order status to delivered
                        this.updateOrderStatus('delivered');
                    }
                });
            }

            showOrderDenialDialog() {
                if (!this.currentEditingOrder) {
                    showToast('No order selected', 'error');
                    return;
                }
                
                const dialog = document.getElementById('orderDenialDialog');
                // Clear any previous reason
                document.getElementById('denialReason').value = '';
                dialog.showModal();
            }
            
            // Handle the actual order denial with optional reason
            proceedWithOrderDenial(denialReason = '') {
                if (!this.currentEditingOrder) return;
                
                // Send notification to the user about order denial
                this.sendOrderDenialNotification(this.currentEditingOrder, denialReason);
                
                // Include denial reason in the update if provided
                this.updateOrderStatus('denied', denialReason);
            }
            
            // Send notification to user when order is denied
            sendOrderDenialNotification(order, denialReason = '') {
                try {
                    const userId = order.userId;
                    if (!userId) {
                        console.warn('No userId found for order, cannot send denial notification');
                        return;
                    }
                    
                    const orderNumber = order.orderNumber || this.generateOrderNumber(order);
                    const customerName = order.fullName || order.buyerinfo || 'Customer';
                    
                    // Create notification message
                    let notificationMessage = `Your order ${orderNumber} has been denied by our staff.`;
                    if (denialReason) {
                        notificationMessage += ` Reason: ${denialReason}`;
                    }
                    notificationMessage += ' Please contact us if you have any questions.';
                    
                    // Create notification object
                    const notification = {
                        id: `denial_${order._id}_${Date.now()}`,
                        userId: userId,
                        title: '‚ùå Order Denied',
                        message: notificationMessage,
                        time: new Date().toISOString(),
                        read: false,
                        type: 'order_denial',
                        orderNumber: orderNumber,
                        orderId: order._id,
                        denialReason: denialReason || null
                    };
                    
                    // Store notification in user-specific localStorage
                    const userNotificationKey = `notifications_${userId}`;
                    const existingNotifications = JSON.parse(localStorage.getItem(userNotificationKey) || '[]');
                    
                    // Add new notification to the beginning of the array
                    existingNotifications.unshift(notification);
                    
                    // Keep only the latest 50 notifications per user
                    if (existingNotifications.length > 50) {
                        existingNotifications.splice(50);
                    }
                    
                    // Save back to localStorage
                    localStorage.setItem(userNotificationKey, JSON.stringify(existingNotifications));
                    
                    console.log(`‚úÖ Denial notification sent to user ${userId} for order ${orderNumber}`);
                    
                    // Also add to staff notifications for tracking
                    this.addNotification({
                        title: `üì§ Denial Notice Sent`,
                        description: `Sent denial notification to ${customerName} for order ${orderNumber}${denialReason ? ` (Reason: ${denialReason})` : ''}`,
                        time: new Date(),
                        type: 'notification_sent'
                    });
                    
                } catch (error) {
                    console.error('Error sending denial notification:', error);
                    showToast('Failed to send denial notification to customer', 'warning');
                }
            }

            showOrderApprovalDialog() {
                if (!this.currentEditingOrder) {
                    showToast('No order selected', 'error');
                    return;
                }
                
                const dialog = document.getElementById('orderApprovalDialog');
                dialog.showModal();
            }

            showOrderDeliveryDialog() {
                if (!this.currentEditingOrder) {
                    showToast('No order selected', 'error');
                    return;
                }
                
                const dialog = document.getElementById('orderDeliveryDialog');
                dialog.showModal();
            }



            // Send notification to user when order is approved
            sendOrderApprovalNotification(order) {
                try {
                    const userId = order.userId;
                    if (!userId) {
                        console.warn('No userId found for order, cannot send approval notification');
                        return;
                    }
                    
                    const orderNumber = order.orderNumber || this.generateOrderNumber(order);
                    const customerName = order.fullName || order.buyerinfo || 'Customer';
                    
                    // Create notification message
                    const notificationMessage = `Great news! Your order ${orderNumber} has been approved and is now being prepared for delivery. We'll notify you when it's ready for pickup or shipment.`;
                    
                    // Create notification object
                    const notification = {
                        id: `approval_${order._id}_${Date.now()}`,
                        userId: userId,
                        title: '‚úÖ Order Approved',
                        message: notificationMessage,
                        time: new Date().toISOString(),
                        read: false,
                        type: 'order_approval',
                        orderNumber: orderNumber,
                        orderId: order._id
                    };
                    
                    // Store notification in user-specific localStorage
                    const userNotificationKey = `notifications_${userId}`;
                    const existingNotifications = JSON.parse(localStorage.getItem(userNotificationKey) || '[]');
                    
                    // Add new notification to the beginning of the array
                    existingNotifications.unshift(notification);
                    
                    // Keep only the latest 50 notifications per user
                    if (existingNotifications.length > 50) {
                        existingNotifications.splice(50);
                    }
                    
                    // Save back to localStorage
                    localStorage.setItem(userNotificationKey, JSON.stringify(existingNotifications));
                    
                    console.log(`‚úÖ Approval notification sent to user ${userId} for order ${orderNumber}`);
                    
                    // Also add to staff notifications for tracking
                    this.addNotification({
                        title: `üì§ Approval Notice Sent`,
                        description: `Sent approval notification to ${customerName} for order ${orderNumber}`,
                        time: new Date(),
                        type: 'notification_sent'
                    });
                    
                } catch (error) {
                    console.error('Error sending approval notification:', error);
                    showToast('Failed to send approval notification to customer', 'warning');
                }
            }

            // Send notification to user when order is delivered
            sendOrderDeliveryNotification(order) {
                try {
                    const userId = order.userId;
                    if (!userId) {
                        console.warn('No userId found for order, cannot send delivery notification');
                        return;
                    }
                    
                    const orderNumber = order.orderNumber || this.generateOrderNumber(order);
                    const customerName = order.fullName || order.buyerinfo || 'Customer';
                    
                    // Create notification message
                    const notificationMessage = `Your order ${orderNumber} has been successfully delivered! Thank you for your business. We hope you're satisfied with your purchase.`;
                    
                    // Create notification object
                    const notification = {
                        id: `delivery_${order._id}_${Date.now()}`,
                        userId: userId,
                        title: 'üöö Order Delivered',
                        message: notificationMessage,
                        time: new Date().toISOString(),
                        read: false,
                        type: 'order_delivery',
                        orderNumber: orderNumber,
                        orderId: order._id
                    };
                    
                    // Store notification in user-specific localStorage
                    const userNotificationKey = `notifications_${userId}`;
                    const existingNotifications = JSON.parse(localStorage.getItem(userNotificationKey) || '[]');
                    
                    // Add new notification to the beginning of the array
                    existingNotifications.unshift(notification);
                    
                    // Keep only the latest 50 notifications per user
                    if (existingNotifications.length > 50) {
                        existingNotifications.splice(50);
                    }
                    
                    // Save back to localStorage
                    localStorage.setItem(userNotificationKey, JSON.stringify(existingNotifications));
                    
                    console.log(`‚úÖ Delivery notification sent to user ${userId} for order ${orderNumber}`);
                    
                    // Also add to staff notifications for tracking
                    this.addNotification({
                        title: `üì§ Delivery Notice Sent`,
                        description: `Sent delivery notification to ${customerName} for order ${orderNumber}`,
                        time: new Date(),
                        type: 'notification_sent'
                    });
                    
                } catch (error) {
                    console.error('Error sending delivery notification:', error);
                    showToast('Failed to send delivery notification to customer', 'warning');
                }
            }

            // Deduct stock from products when order is approved
            async deductStockForOrder(order) {
                if (!order || !order.itemsordered || order.itemsordered.length === 0) {
                    console.warn('No items found in order to deduct stock');
                    return;
                }

                try {
                    console.log('üîÑ Deducting stock for order approval...', order._id);
                    
                    // Prepare stock updates array
                    const stockUpdates = order.itemsordered.map(item => ({
                        id: item.item_id,
                        quantity: parseInt(item.amount_per_item) || 0
                    }));

                    console.log('üì¶ Stock updates to be processed:', stockUpdates);

                    // Call the bulk stock update API
                    const response = await fetch('http://localhost:3000/api/products/bulk-stock', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ updates: stockUpdates })
                    });

                    if (!response.ok) {
                        const errorData = await response.text();
                        throw new Error(`Failed to update product stock: ${errorData}`);
                    }

                    const result = await response.json();
                    console.log('‚úÖ Stock successfully deducted from products:', result);

                    // Update local product data to reflect the changes
                    stockUpdates.forEach(update => {
                        const product = this.products.find(p => p.id === update.id);
                        if (product) {
                            product.stock = Math.max(0, product.stock - update.quantity);
                            console.log(`üì¶ Updated local stock for ${product.name}: ${product.stock}`);
                        }
                    });

                    // Add staff notification about stock deduction
                    const orderNumber = order.orderNumber || this.generateOrderNumber(order);
                    this.addNotification({
                        title: 'üì¶ Stock Deducted',
                        description: `Stock deducted for approved order ${orderNumber} (${stockUpdates.length} items)`,
                        time: new Date(),
                        type: 'stock_update'
                    });

                    showToast('Stock successfully deducted from products', 'success');

                } catch (error) {
                    console.error('‚ùå Error deducting stock for order:', error);
                    throw new Error(`Stock deduction failed: ${error.message}`);
                }
            }

            // Show order return dialog
            showOrderReturnDialog() {
                if (!this.currentEditingOrder) {
                    showToast('No order selected', 'error');
                    return;
                }
                
                const dialog = document.getElementById('orderReturnDialog');
                // Clear any previous data
                document.getElementById('returnReason').value = '';
                this.clearReturnImage();
                dialog.showModal();
            }

            // Setup order return dialog
            setupOrderReturnDialog() {
                const dialog = document.getElementById('orderReturnDialog');
                
                // Prevent duplicate listeners by checking if already set up
                if (dialog.dataset.setupComplete === 'true') {
                    return;
                }
                dialog.dataset.setupComplete = 'true';
                
                // Add event listener for dialog close
                dialog.addEventListener('close', () => {
                    if (dialog.returnValue === 'confirm') {
                        const returnReason = document.getElementById('returnReason').value.trim();
                        const returnImage = this.getReturnImageData();
                        this.proceedWithOrderReturn(returnReason, returnImage);
                    }
                });

                // Setup drag and drop for return image
                this.setupReturnImageUpload();
            }

            // Handle the actual order return with reason and image
            proceedWithOrderReturn(returnReason = '', returnImage = null) {
                if (!this.currentEditingOrder) return;
                
                // Send notification to the user about order return
                this.sendOrderReturnNotification(this.currentEditingOrder, returnReason);
                
                // Update order status to returned with additional data
                this.updateOrderStatusWithData('returned', {
                    returnReason: returnReason,
                    returnImage: returnImage,
                    returnDate: new Date().toISOString()
                });
            }

            // Send notification to user when order is returned
            sendOrderReturnNotification(order, returnReason = '') {
                try {
                    const userId = order.userId;
                    if (!userId) {
                        console.warn('No userId found for order, cannot send return notification');
                        return;
                    }
                    
                    const orderNumber = order.orderNumber || this.generateOrderNumber(order);
                    const customerName = order.fullName || order.buyerinfo || 'Customer';
                    
                    // Create notification message
                    let notificationMessage = `Your order ${orderNumber} has been processed as returned.`;
                    if (returnReason) {
                        notificationMessage += ` Return reason: ${returnReason}`;
                    }
                    notificationMessage += ' Please contact us if you have any questions about the return process.';
                    
                    // Create notification object
                    const notification = {
                        id: `return_${order._id}_${Date.now()}`,
                        userId: userId,
                        title: '‚Ü©Ô∏è Order Returned',
                        message: notificationMessage,
                        time: new Date().toISOString(),
                        read: false,
                        type: 'order_return',
                        orderNumber: orderNumber,
                        orderId: order._id,
                        returnReason: returnReason || null
                    };
                    
                    // Store notification in user-specific localStorage
                    const userNotificationKey = `notifications_${userId}`;
                    const existingNotifications = JSON.parse(localStorage.getItem(userNotificationKey) || '[]');
                    
                    // Add new notification to the beginning of the array
                    existingNotifications.unshift(notification);
                    
                    // Keep only the latest 50 notifications per user
                    if (existingNotifications.length > 50) {
                        existingNotifications.splice(50);
                    }
                    
                    // Save back to localStorage
                    localStorage.setItem(userNotificationKey, JSON.stringify(existingNotifications));
                    
                    console.log(`‚úÖ Return notification sent to user ${userId} for order ${orderNumber}`);
                    
                    // Also add to staff notifications for tracking
                    this.addNotification({
                        title: `üì§ Return Notice Sent`,
                        description: `Sent return notification to ${customerName} for order ${orderNumber}${returnReason ? ` (Reason: ${returnReason})` : ''}`,
                        time: new Date(),
                        type: 'notification_sent'
                    });
                    
                } catch (error) {
                    console.error('Error sending return notification:', error);
                    showToast('Failed to send return notification to customer', 'warning');
                }
            }

            // Setup return image upload with drag and drop
            setupReturnImageUpload() {
                const dropZone = document.getElementById('returnDropZone');
                const fileInput = document.getElementById('returnFileInput');
                const removeBtn = document.getElementById('removeReturnImageBtn');

                // Click to browse
                dropZone.addEventListener('click', () => {
                    fileInput.click();
                });

                // File input change
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleReturnFileSelect(e.target.files[0]);
                    }
                });

                // Remove image button
                removeBtn.addEventListener('click', () => {
                    this.clearReturnImage();
                });

                // Drag and drop events
                dropZone.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });

                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });

                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    if (!dropZone.contains(e.relatedTarget)) {
                        dropZone.classList.remove('dragover');
                    }
                });

                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].type.startsWith('image/')) {
                        this.handleReturnFileSelect(files[0]);
                    } else {
                        showToast('Please drop a valid image file', 'error');
                    }
                });
            }

            // Handle file selection for return image
            handleReturnFileSelect(file) {
                if (!file || !file.type.startsWith('image/')) {
                    showToast('Please select a valid image file', 'error');
                    return;
                }

                const maxSize = 5 * 1024 * 1024; // 5MB
                if (file.size > maxSize) {
                    showToast('Image file is too large. Please select a file under 5MB.', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const previewImg = document.getElementById('returnPreviewImg');
                    const imagePreview = document.getElementById('returnImagePreview');
                    const dropZoneContent = document.querySelector('#returnDropZone .drop-zone-content');
                    const removeBtn = document.getElementById('removeReturnImageBtn');

                    previewImg.src = e.target.result;
                    imagePreview.classList.remove('hidden');
                    dropZoneContent.style.display = 'none';
                    removeBtn.classList.remove('hidden');

                    showToast('Return documentation image uploaded successfully', 'success');
                };
                reader.readAsDataURL(file);
            }

            // Clear return image
            clearReturnImage() {
                const previewImg = document.getElementById('returnPreviewImg');
                const imagePreview = document.getElementById('returnImagePreview');
                const dropZoneContent = document.querySelector('#returnDropZone .drop-zone-content');
                const removeBtn = document.getElementById('removeReturnImageBtn');
                const fileInput = document.getElementById('returnFileInput');

                previewImg.src = 'images/sanrico_logo_1.png';
                imagePreview.classList.add('hidden');
                dropZoneContent.style.display = 'block';
                removeBtn.classList.add('hidden');
                fileInput.value = '';
            }

            // Get return image data
            getReturnImageData() {
                const previewImg = document.getElementById('returnPreviewImg');
                const imagePreview = document.getElementById('returnImagePreview');
                
                if (!imagePreview.classList.contains('hidden') && previewImg.src && !previewImg.src.includes('sanrico_logo_1.png')) {
                    return previewImg.src;
                }
                return null;
            }

            // Update order status with additional data
            async updateOrderStatusWithData(newStatus, additionalData = {}) {
                if (!this.currentEditingOrder) return;
                
                try {
                    const currentStatus = this.currentEditingOrder.status;
                    const order = this.currentEditingOrder;
                    
                    // Check if the status is already set to the selected value
                    const normalizedCurrentStatus = currentStatus === 'active' ? 'pending' : currentStatus;
                    
                    if (normalizedCurrentStatus === newStatus) {
                        const statusDisplayName = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
                        showToast(`Order is already ${statusDisplayName}`, 'warning');
                        return;
                    }
                    
                    // Validate status transitions
                    if (!this.isValidStatusTransition(normalizedCurrentStatus, newStatus)) {
                        showToast('Invalid status transition', 'error');
                        return;
                    }
                    
                    // Determine target collection and operation
                    let targetCollection;
                    let moveOperation;
                    
                    switch (newStatus) {
                        case 'pending':
                            targetCollection = 'orders';
                            moveOperation = 'moveToPending';
                            break;
                        case 'approved':
                            targetCollection = 'accepted';
                            moveOperation = 'moveToAccepted';
                            break;
                        case 'delivered':
                            targetCollection = 'delivered';
                            moveOperation = 'moveToDelivered';
                            break;
                        case 'returned':
                            targetCollection = 'returned';
                            moveOperation = 'moveToReturned';
                            break;
                        case 'denied':
                            targetCollection = 'denied';
                            moveOperation = 'moveToDenied';
                            break;
                        default:
                            showToast('Invalid status', 'error');
                            return;
                    }
                    
                    // Prepare request body with additional data
                    const requestBody = {
                        orderId: order._id,
                        operation: moveOperation,
                        fromCollection: this.getOrderCollection(order),
                        toCollection: targetCollection
                    };
                    
                    // Add specific data based on status
                    if (newStatus === 'denied' && additionalData.denialReason) {
                        requestBody.denialReason = additionalData.denialReason;
                    }
                    
                    if (newStatus === 'returned') {
                        if (additionalData.returnReason) {
                            requestBody.returnReason = additionalData.returnReason;
                        }
                        if (additionalData.returnImage) {
                            requestBody.returnImage = additionalData.returnImage;
                        }
                    }
                    
                    // Make API call to update status
                    const response = await fetch('http://localhost:3000/api/orders/move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        let successMessage = `Order status updated to ${newStatus}`;
                        
                        if (newStatus === 'denied' && additionalData.denialReason) {
                            successMessage += ` (Reason: ${additionalData.denialReason})`;
                        }
                        
                        if (newStatus === 'returned') {
                            if (additionalData.returnReason) {
                                successMessage += ` (Reason: ${additionalData.returnReason})`;
                            }
                            if (additionalData.returnImage) {
                                successMessage += ` with documentation`;
                                
                                // Add notification for return documentation
                                this.addNotification({
                                    title: 'üì∑ Return Documentation',
                                    description: `Return image uploaded for order ${order.orderNumber || this.generateOrderNumber(order)}`,
                                    time: new Date(),
                                    type: 'return_documentation'
                                });
                            }
                        }
                        
                        showToast(successMessage, 'success');
                        
                        // Close modal and refresh orders
                        document.getElementById('orderModal').classList.remove('show');
                        this.currentEditingOrder = null;
                        
                        // Refresh the orders list
                        await this.loadOrders();
                        this.renderOrders();
                        
                    } else {
                        const errorData = await response.text();
                        console.error('Error updating order status:', errorData);
                        showToast('Failed to update order status', 'error');
                    }
                    
                } catch (error) {
                    console.error('Error updating order status with data:', error);
                    showToast('Failed to update order status', 'error');
                }
            }

            // Generic file select handler for product modal
            handleFileSelect(file) {
                if (!file || !file.type.startsWith('image/')) {
                    showToast('Please select a valid image file', 'error');
                    return;
                }

                const maxSize = 5 * 1024 * 1024; // 5MB
                if (file.size > maxSize) {
                    showToast('Image file is too large. Please select a file under 5MB.', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const previewImg = document.getElementById('previewImg');
                    const imagePreview = document.getElementById('imagePreview');
                    const dropZoneContent = document.querySelector('#dropZone .drop-zone-content');
                    const removeBtn = document.getElementById('removeImageBtn');

                    previewImg.src = e.target.result;
                    imagePreview.classList.remove('hidden');
                    dropZoneContent.style.display = 'none';
                    removeBtn.classList.remove('hidden');

                    showToast('Product image uploaded successfully', 'success');
                };
                reader.readAsDataURL(file);
            }

            // Generic remove image handler for product modal
            removeImage() {
                const previewImg = document.getElementById('previewImg');
                const imagePreview = document.getElementById('imagePreview');
                const dropZoneContent = document.querySelector('#dropZone .drop-zone-content');
                const removeBtn = document.getElementById('removeImageBtn');
                const fileInput = document.getElementById('fileInput');

                previewImg.src = 'images/sanrico_logo_1.png';
                imagePreview.classList.add('hidden');
                dropZoneContent.style.display = 'block';
                removeBtn.classList.add('hidden');
                fileInput.value = '';

                showToast('Image removed', 'info');
            }

            // View return request details
            viewReturn(returnId) {
                const returnRequest = this.returns.find(r => r._id === returnId);
                if (!returnRequest) {
                    showToast('Return request not found', 'error');
                    return;
                }

                // Use the existing order modal to display return details
                this.currentEditingOrder = returnRequest;
                this.viewOrder(returnId);
            }

            // Process return request
            processReturn(returnId) {
                const returnRequest = this.returns.find(r => r._id === returnId);
                if (!returnRequest) {
                    showToast('Return request not found', 'error');
                    return;
                }

                // Show the return dialog
                this.currentEditingOrder = returnRequest;
                this.showOrderReturnDialog();
            }
        }

        // Initialize Enhanced Staff Dashboard
        const staffDashboard = new EnhancedStaffDashboard();

        // Close notification dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const notificationBtn = document.getElementById('notificationBtn');
            const notificationDropdown = document.getElementById('notificationDropdown');
            
            if (!notificationBtn.contains(e.target) && !notificationDropdown.contains(e.target)) {
                notificationDropdown.classList.remove('show');
            }
        });

        // Global helper functions for the modern modal
        function copyStaffOrderId() {
            const orderIdElement = document.getElementById('staffModalOrderId');
            const orderText = orderIdElement.textContent;
            
            // Use the Clipboard API if available
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(orderText).then(() => {
                    showToast('Order ID copied to clipboard!', 'success');
                }).catch(() => {
                    fallbackCopyTextToClipboard(orderText);
                });
            } else {
                fallbackCopyTextToClipboard(orderText);
            }
        }

        // Fallback copy function
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0";
            textArea.style.left = "0";
            textArea.style.position = "fixed";
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showToast('Order ID copied to clipboard!', 'success');
            } catch (err) {
                showToast('Failed to copy order ID', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        // Initialize Enhanced Staff Dashboard after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeStaffDashboard();
        });
    </script>
</body>
</html>
